<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chakkk</title>
  
  
  <link href="https://chakkk309.github.io/atom.xml" rel="self"/>
  
  <link href="https://chakkk309.github.io/"/>
  <updated>2022-08-25T19:25:32.540Z</updated>
  <id>https://chakkk309.github.io/</id>
  
  <author>
    <name>Jiaqi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>开源项目申请</title>
    <link href="https://chakkk309.github.io/2022/08/26/projectlist/"/>
    <id>https://chakkk309.github.io/2022/08/26/projectlist/</id>
    <published>2022-08-26T12:42:33.309Z</published>
    <updated>2022-08-25T19:25:32.540Z</updated>
    
    <content type="html"><![CDATA[<p>分享几个学生可以参与的开源活动，基本上从 3-6月开始和导师沟通，暑假开发，对于想参与开源但又无从下手的同学是一个非常好的机会。</p><h2 id="gsoc---google-summer-of-code">GSoC - Google Summer of Code</h2><p>由 Google 举办的开源之夏活动 <ahref="https://summerofcode.withgoogle.com/">GSoC</a> ，可参考22年 <ahref="https://developers.google.com/open-source/gsoc/timeline">时间线</a>，3.7开始和导师沟通，4.19截止提交提案，5.20 宣布中选结果，开发时间从六月到九月。</p><p>每年都有固定的开源社区参与，如果有感兴趣的项目可以查看往年的organization 或是 idea 列表，提前参与社区沟通。</p><h2 id="ospp---open-source-promotion-plan">OSPP - Open Source PromotionPlan</h2><p>中科院研究所联合华为举办的开源之夏活动 <ahref="https://summer-ospp.ac.cn/">OSPP</a>，2022年时间线如下，有几个比较重要的时间节点：4.21 开始联系导师沟通项目，5.21开始提交项目申请书，6.15 公布中选结果。</p><center><img src="OSPP.png" alt="OSPP" style="zoom:120%;" /></center><p>项目非常多，124 个社区参与，共有 502 个<ahref="https://summer-ospp.ac.cn/#/org/projectlist">项目</a>。而且大多是基础软件类别的，相比于GSoC，有大量云原生与数据库项目，非常之诱人:)</p><center><img src="OSPP-categories.jpg" alt="OSPP" style="zoom:80%;" /></center><h2 id="mlh-fellowship">MLH Fellowship</h2><p>MLHFellowship每年有多批次项目开放，申请者在<strong>一个批次中只能申请一个项目</strong>，开发周期为12周。申请时要填codesample的链接，审核人是会比较仔细地看所给的code的。与其他项目不同，首先需要提交关于自身经历的申请，会根据你的经历为你匹配适合的项目，官方匹配而不是申请者自行选择。详情见项目<ahref="https://fellowship.mlh.io/">官网</a>，可查看过往项目申请者的<ahref="https://dev.to/t/mlhgrad">repo</a>。</p><h2 id="linux-foundation-mentorship-program">Linux Foundation MentorshipProgram</h2><p>Linux基金会导师计划，详情见<ahref="https://lfx.linuxfoundation.org/tools/mentorship/">官网</a>，项目大多是Linux内核，云原生之类的。春季，夏季秋季均有申请项目，part-time周期一般是六个月。申请流程一般是创建账号，完善资料，寻找感兴趣的项目，提交申请后还需要完成一些能够快速熟悉社区和项目的小任务，任务完成之后才能和社区的导师沟通交流，最终给出申请结果。还是有一定的门槛的，申请时需要对项目有基本的了解，需要投入的时间成本会比较大，谨慎选择。</p><h2 id="asoc---阿里巴巴编程之夏">ASoC - 阿里巴巴编程之夏</h2><p><a href="https://asoc2022.opensource.alibaba.com/">ASoC</a>是阿里举办的开源之夏活动，2019年举办了第一届阿里巴巴开源之夏，在每年的四月底或五月份左右宣布项目，项目和名额比较GSoC 和 OSPP要少很多，但是好处是报名时间上较前两个活动较晚，竞争压力会小很多，在其他活动中还没有申请到满意项目的同学可以冲一下，2022年ASoC 时间线：</p><center><img src="ASoC.png" alt="ASoC" style="zoom:100%;" /></center><h2 id="腾讯犀牛鸟计划">腾讯犀牛鸟计划</h2><p>教育部和腾讯联合举办的 <ahref="https://opensource.tencent.com/summer-of-code">犀牛鸟开源人才培养计划</a>，今年是第二届，有腾讯内部的几个开源项目。这个活动好像分为前后两个阶段，不是所有人都能参与最后阶段获得奖金的，时间充裕的朋友可以试试这个。</p><center><img src="Rhino-bird.jpg" alt="Rhino-bird" style="zoom:70%;" /></center><h2 id="openeuler-开源实习">openEuler 开源实习</h2><p><ahref="https://www.openeuler.org/zh/internship/">openEuler开源实习</a> 是openEuler和社区合作单位共同发起的线上实习项目，签订实习协议，有效期最长为6个月，完成相应的社区任务最后在每个月可根据积分获得工资。</p><h2 id="weopen-star-开源计划">WeOpen Star 开源计划</h2><p>腾讯的 <ahref="https://github.com/weopenprojects/WeOpen-Star">开源摘星计划</a>是由腾源会 2022 年推出的全新项目，活动时间是由 5 月中旬-12月底，不限制身份，不管是否学生还是已经参加工作，都可以参与该项目。但没有直接的现金奖励，可以查看2022 年支持的 <ahref="https://github.com/weopenprojects/WeOpen-Star/blob/main/Projects-list/README.md">项目列表</a>，根据贡献指南参与社区建设。</p><p><br></p><blockquote><p>update：2022/08/04</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;分享几个学生可以参与的开源活动，基本上从 3-6
月开始和导师沟通，暑假开发，对于想参与开源但又无从下手的同学是一个非常好的机会。&lt;/p&gt;
&lt;h2 id=&quot;gsoc---google-summer-of-code&quot;&gt;GSoC - Google Summer of Code&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Database Storage</title>
    <link href="https://chakkk309.github.io/2022/03/19/databasestorage/"/>
    <id>https://chakkk309.github.io/2022/03/19/databasestorage/</id>
    <published>2022-03-19T09:26:00.000Z</published>
    <updated>2022-08-26T16:55:14.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="database-storage-i">Database Storage I</h1><h2 id="存储分层">1. 存储分层</h2><p>大部分数据库中的数据是在硬盘中的，用户操作数据时需要把数据加载到内存中，最后将修改后的数据重新写入硬盘。数据库存储模块就需要管理数据库从磁盘到内存中流动的过程。</p><p>在存储层次结构中，离CPU最近的设备是CPU寄存器，它是最快也是最小最贵的存储，其次是CPU缓存和DRAM。离CPU越远存储设备就越大越慢，但是也越便宜，如：固态硬盘，机械硬盘和网络带宽。<img src="image-20220116204634712.png" alt="Storage Hierarchy" /></p><h4 id="易失性存储">易失性存储</h4><h4 id="examples-cpu-registers-cpu-caches-dram">- Examples: CPURegisters, CPU caches, DRAM</h4><ul><li><p>不稳定，一掉电数据就会丢失</p></li><li><p>支持随机访问，程序可以按字节访问任意地址获取数据</p></li><li><p>通常将这类存储称为“内存”</p></li></ul><h4 id="非易失性存储">非易失性存储</h4><h4 id="examples-ssd-hdd-network-storage">- Examples: SSD, HDD, NetworkStorage</h4><ul><li>断电后数据不丢失</li><li>按块/页寻址，比如：块的大小为1KB，就算要存储1字节数据也需要耗费1KB的空间。按块存储没办法获取到具体某一个字节的数据，读的时候只能把整个块读到内存当中，再进行解析逐个读取；修改也是同理，都是以块为单位进行存取</li><li>顺序存储，可以同时读取多个连续的数据块</li><li>通常将这类存储称为“磁盘”</li></ul><figure><img src="image-20220116213455155.png" alt="Storage Hierarchy" /><figcaption aria-hidden="true">Storage Hierarchy</figcaption></figure><p>有一些比较新的存储设备，如Non-volatileMemory，字面理解为“非易失性内存”，又快有可以保证磁盘持久性，但这种设备目前还没有广泛的生产使用。</p><p>由于DBMS体系结构假定数据库存储在磁盘上，因此DBMS的组件负责确定如何在非易失性磁盘和易失性内存之间移动数据，因为系统不能直接在磁盘上操作数据，这样性能会非常差。从磁盘获取数据非常慢。如果从L1缓存读取数据需要半秒，那么从SSD读取数据则需要1.7天，从HDD读取数据需要16.5周。</p><p>其中TapeArchives是磁带盘，一小块可以存储几十个G，数据用磁头写入到磁带，容量超大但读取超慢。但是磁性存储是最不容易损坏的，只要不经常读取，这种存储性质是非常稳定的，多用来做不重要的数据备份与存档。</p><p>存在内存中需要100m，而存到内存上需要1.7天，所以不可能把所有数据实时存储到内存中。我们将专注于隐藏磁盘的延迟，而不是使用寄存器和缓存进行优化，</p><h4 id="不同存储设备访问时间">不同存储设备访问时间：</h4><figure><img src="image-20220116213853826.png" alt="Access Times" /><figcaption aria-hidden="true">Access Times</figcaption></figure><h4 id="随机存取和连续存储">随机存取和连续存储</h4><p>一般来说连续存取要比随机存取快得多得多。用户的存取都是随机的，尽量把随机存取转换成数据库对磁盘的连续存取。</p><p>如：可以先缓存用户的部分查询内容，再找一个合适的时间一次性写入磁盘</p><h4 id="存储引擎的设计目标">存储引擎的设计目标</h4><ul><li><p>机器只有8个G的内存，不能说只能存储8个G的数据，可能磁盘有10个G的容量。要允许用户存储大于8个G的数据，在内存中管理巨大的数据库</p><p>坏的设计：假设一份PPT很大，把数据全部加载到内存中的时间很长，甚至不能全部加载到内存中</p><p>好的设计：PPT可以逐页加载到内存中</p></li><li><p>读写磁盘的代价是巨大的，需要小心管理数据存取，不要让数据库经常读写磁盘</p></li><li><p>尽量要把随机的读取转换成顺序的读写</p></li></ul><figure><img src="image-20220116220652189.png" alt="System Design Goals" /><figcaption aria-hidden="true">System Design Goals</figcaption></figure><h2 id="面向硬盘的关系型数据库">2. 面向硬盘的关系型数据库</h2><p>不论数据库设计再复杂，最终数据都要落在硬盘中的某个文件，也就是说数据在硬盘中的存储形式是<strong>文件</strong></p><p>一个文件会被分成多个页，第一页是目录页，指明哪个数据在哪个页上，页有固定的大小。每个页中含有一个Header，用来解释数据的一些属性。</p><p>数据库需要将数据存入内存，它有一个缓冲池来管理数据在磁盘和内存之间来回移动。</p><p>-为什么是一个池呢？因为需要控制数据库的大小</p><p>数据库需要执行引擎（执行器）来执行查询，执行引擎将向缓冲池请求特定页面，而缓冲池负责将该页面放入内存，并在内存中给执行引擎一个指向该页面的指针</p><p>假设执行器要读取一个表，发现数据应该在文件中的第二页。它会去缓冲池里面找。缓冲池会将文件目录加载到内存中，找到了第二页的位置，再去磁盘中拉取第二页的内容到内存，那么执行器就会对第二页进行一些解析与操作。</p><p><img src="image-20220116221214357.png" alt="Disk-Oriented DBMS 1" /><img src="image-20220116222059161.png" alt="Disk-Oriented DBMS 2" /></p><p>数据库存储：数据库是如何在硬盘中是如何表示成文件的？（静态的表现）</p><h2 id="file-storage">3. File storage</h2><p>数据库把用户数据存储在磁盘中的一个或多个文件中。操作系统不知道也不关心文件的内容，这些内容以数据特有的方式进行编码。</p><p><strong>存储管理器（StorageManager）</strong>负责管理或维护数据库里的文件，一般会把文件当成一组页的集合，它还跟踪哪些数据被读取和写入页面，以及这些页面中有多少空闲空间。</p><h2 id="database-pages">4. Database pages</h2><p>DBMS跨一个或多个文件组织数据库，这些文件是固定大小的数据块，称为页，数据库文件太大了，不可能把文件当成一个单元进行管理。</p><ul><li>这些数据块可能包含tuple，indexes，log records这些内容</li><li>每个数据库的页都是功能固定的，大多数系统不会在页面中混合存储</li><li>一些系统要求页是自解释的，这意味着读取每个页面所需的所有信息都在页面本身</li><li>每一个页都有唯一的标识符id。如果数据库是一个文件，那么页面id可以只是文件偏移量</li></ul><blockquote><p>大多数DBMS都有一个间接层，将页面id映射到文件路径和偏移量。系统的上层会请求一个特定的页码。然后，存储管理器必须将页码转换为一个文件和一个偏移量来找到该页</p></blockquote><p>有三个不同的层面“页”概念：</p><ul><li><p><strong>硬盘页</strong>: 4 KB</p><p>一个机械磁盘往往是4 KB一个块，有一些SSD块大小可能为0.5KB，是最小的可以保证原子操作的单位,，即要么全部写入，要么全部不写入</p><p>这意味着，如果数据库页面比硬件页面大，DBMS将不得不采取额外的措施，以确保安全地写入数据，因为当系统崩溃时，程序可以在将数据库页面写入磁盘的过程中中途完成。</p></li><li><p><strong>操作系统页</strong>: 4 KB</p><p>应用软件没有办法和硬件直接交互，需要先存进OS，再由OS与硬盘交互</p></li><li><p><strong>数据库页</strong>: 512 B-16 KB</p><blockquote><p>大多数DBMS使用固定大小的页面，以避免支持可变大小页面所需的工程开销。例如，对于大小可变的页面，删除一个页面可能会在文件中创建一个空洞，而DBMS无法轻易地用新页面来填充这个空洞。</p></blockquote><p>数据库应用自己定义的存取数据的最小单位，512B可能是一些便携式设备（手机或嵌入式操作系统）。数据库页16KB取硬盘和操作系统页的整数页，常见数据库的页大小如下：</p><ul><li>4 KB: SQLite, DB2, ORACLE</li><li>8 KB: SQL Server, PostgreSQL</li><li>6 KB: MySQL</li></ul></li></ul><h2 id="database-heap">5. Database heap</h2><p>有几种方法可以找到DBMS需要的页面在磁盘上的位置，堆文件组织就是其中一种方法。堆文件是一个无序的页面集合，其中元组按随机顺序存储</p><p>堆文件，一堆无序的页，每页存储了一些数据（随机/顺序）。这个页需要有增删改查的功能，还要支持迭代遍历所有的页。</p><figure><img src="image-20220116224421478.png" alt="Database Heap" /><figcaption aria-hidden="true">Database Heap</figcaption></figure><p>通过使用页链表或页目录，DBMS可以在给定页id的情况下定位磁盘上的页：</p><ul><li><p>linked list: 头页 包含指向 空闲页面列表 和数据页面列表的指针。如果DBMS正在寻找一个指定的页，它必须对数据页面列表顺序扫描，直到找到该页</p></li><li><p>page directory:DBMS维护的特殊的页，这些页跟踪数据页的位置以及每个页上的空闲空间量</p></li></ul><p><img src="image-20220116224614718.png" alt="Linked List" /> <imgsrc="image-20220116224628548.png" alt="Page Directory" /></p><h2 id="page-layout">6. Page Layout</h2><h4 id="page-header">Page Header</h4><p>每一页中有一个数据头，其中包含一些元数据 <imgsrc="image-20220116224908013.png" alt="Page Header" /></p><ul><li>页大小</li><li>检验和：检查数据是否丢失</li><li>数据库版本：数据库升级时，有可能它们不兼容</li><li>事务可见性：事务和并发相关</li><li>压缩信息：数据页在存储时通常是被压缩的</li></ul><p>在一个页中是如何存储元组的？</p><p>跟踪DBMS在一个页面中存储了多少元组，然后在每次添加一个新的元组时将其附加到末尾。但是，当元组被删除或元组具有可变长度的属性时，就会出现问题。</p><p>Q1：删除一个元组会怎么样？</p><p>Q2：存储一个可变长度的数据怎么办？</p><h4 id="数据的组织形式-槽页面和日志结构">数据的组织形式:槽页面和日志结构</h4><p><strong>slottedpages</strong>：页面将插槽映射到偏移量，页里存储的是数据</p><ul><li><p>DBMS中最常用的方法</p></li><li><p>Header记录了使用的槽数，最后一个使用的槽的起始位置的偏移量，以及一个槽数组，它记录了每个元组的起始位置。</p></li><li><p>添加一个元组，槽数组将从开始到结束增长，元组的数据将从结束到开始增长。当槽数组和元组数据满足时，该页被认为是满的。<img src="image-20220116225551497.png" alt="Slotted Pages 1" /> <imgsrc="image-20220116225551497.png" alt="Slotted Pages 2" /></p></li></ul><p><strong>log structure</strong>:DBMS只存储日志记录，不存储元组，页里存储的是操作日志</p><ul><li>将数据库如何被修改(插入、更新、删除)的记录存储到文件中。</li><li>为了读取一条记录，DBMS会反向扫描日志文件并“重新创建”元组。</li><li>写得快，读得慢。</li><li>适用于仅追加存储，DBMS不能返回和更新数据。</li><li>为了避免长时间的读取，DBMS可以有索引来允许它跳转到日志中的特定位置。它还可以周期性地压缩日志。(如果它有一个元组，然后对它进行了更新，它可以将其压缩到只插入更新后的元组)压缩的问题是DBMS最终会产生写放大(它一遍又一遍地重写相同的数据)</li></ul><h4 id="日志压缩">日志压缩</h4><p>日志结构文件：元组中存的不是数据本身，而是数据的变化（LOG)</p><ul><li><p>新增</p></li><li><p>删数据不是删除数据，而是写一条日志说明哪条数据被删除</p></li><li><p>修改数据是新写入一条LOG说明数据被修改了</p></li></ul><p>例：存的不是数据本身，存的是数据的变化</p><center><img alt="LOG" src="image-20220120124208951.png" style="zoom:50%;" /></center><p>如何从日志中读数据呢？</p><p>需要重放LOG，把和这个数据相关的所有LOG找出来，推断并进行回放。往往是从最新的LOG向最旧的寻找，直到该条数据操作的时候。为了提升查找效率，可以添加类似索引的内容。</p><center><img alt="INDEX LOG" src="image-20220120124356647.png" style="zoom:50%;" /></center><p>这样下去，数据修改的次数多了数据库中的LOG会变得非常庞大，通常情况下会周期性地压缩LOG：</p><center><img alt="LOG" src="image-20220120124527816.png" style="zoom:50%;" /></center><center><img alt="LOG COMPACTION" src="image-20220120124509458.png" style="zoom:50%;" /></center><p>DELETE id =4 为什么压缩不了呢？因为插入的数据不在该页内</p><p>什么样的数据库使用这种压缩机制呢？HBASE、cassandra、levelDB、RockDB</p><p>这种机制大多用在kv数据库上，因为一条数据只有一个键一个值；如果只关系型数据库，一条记录只记录修改一个字段，还需要寻找表中的其他字段。</p><h4 id="压缩的其他方法">压缩的其他方法</h4><p><strong>Level Compaction（按层压缩）</strong></p><p>如果一个数据的插入语句和修改（删除）不在一个页上，内部压缩是压缩不了的。可以将两个块合并后再进行压缩（RockDB基本原理，最多能压缩到第七层）</p><p>如何读数据？从第0层开始读，如果没有数据内容，再去寻找第1层，一直找到第7层。</p><p><strong>Universal compaction（不分层压缩）</strong></p><p>同级压缩，是通用的压缩方法： <img src="image-20220120125110306.png"alt="Universal Compaction" /></p><h5 id="log的好处">LOG的好处</h5><p>插入时可以将随机写转换成顺序写。修改k=100的数据（数据页读+改+写回），新建最新的块向里面写日志，但是读数据和压缩时比较麻烦。</p><h2 id="tuple-layout">7. Tuple Layout</h2><p>tuple在磁盘上的表现是一组二进制字节，数据库的工作就是将这些数据编码好放在磁盘上（解释为属性类型和值）</p><h4 id="tuple-header">Tuple Header</h4><ul><li><p>DBMS并发控制协议的可见性信息(例如，关于哪个事务创建/修改了那个元组的信息)</p></li><li><p>NULL值的位映射：数据库列中的数据可以存null，header中往往有一堆二进制位表示后面的数据是不是null</p><p>数据与数据是连续存储的，为避免读错数据要记录下哪个字段存的是null</p></li></ul><p>注：不需要存储关于数据库模式的元数据 | tuple里面不需要存储表结构 <imgsrc="image-20220116230029080.png" alt="Tuple Header" /></p><h4 id="元组数据">元组数据</h4><ul><li><p>属性的实际数据，属性通常按照创建表时指定的顺序存储</p></li><li><p>大多数DBMS不允许tuple超过一个page的大小 <imgsrc="image-20220116230233794.png" alt="Tuple Data" /></p></li></ul><h4 id="唯一识别符">唯一识别符</h4><ul><li><p>数据库中的每个元组都被分配一个唯一的标识符，在全局寻找数据时使用</p></li><li><p>一般的计算方式为：<code>page_id + offset/slot</code></p></li><li><p>应用程序不能依赖这些id来表示任何东西，recordid是数据库内部的一个id，在外部只能用主键这些来查找</p><p>-PostgreSQL使用6-bytes的CTID来表示</p><p>-SQLite使用8-bytes的ROWID来表示</p><p>-ORACLE使用10-bytes的ROWID来表示</p></li></ul><h4 id="非规范化元组数据">非规范化元组数据</h4><p>如果两个表是相关的，DBMS可以“预连接”它们，这样两个表最终会在同一个页面上。这使得读取速度更快，因为DBMS只需要加载一个页面，而不是两个单独的页面。但是，由于DBMS需要为每个元组提供更多的空间，因此更新成本更高。</p><h1 id="database-storage-ii">Database Storage II</h1><h2 id="数据的表现形式">1.数据的表现形式</h2><p>元组中的数据本质上就是字节数组，DBMS应该知道如何解释这些字节来获得属性的值，数据表示方案是DBMS存储值的字节的方式。<img src="image-20220120125413788.png" alt="Data Representation" /></p><p>有五种高级数据类型可以存储在元组中：</p><h3 id="integers">1.1 Integers</h3><p><strong>- Examples: INTEGER, BIGINT, SMALLINT, TINYINT</strong></p><p>大多数DBMS使用IEEE-754标准所指定的原生C/C++类型来存储整数，这些值是固定长度的。</p><h3 id="variable-precious-numbers">1.2 Variable Precious Numbers</h3><p><strong>- Examples: FLOAT, REAL</strong></p><p>对变精度数字的操作比任意精度数字的运算速度更快，因为CPU可以直接对它们执行指令。然而，由于某些数字无法精确表示，在进行计算时可能会出现舍入误差</p><p>如计算可变精度浮点数是 0.1+0.2 是否与0.3 相等：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-type">float</span> x = <span class="hljs-number">0.1</span>;<br>    <span class="hljs-type">float</span> y = <span class="hljs-number">0.2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x+y = %f\n&quot;</span>, x+y);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0.3 = %f\n&quot;</span>, <span class="hljs-number">0.3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果输出，小数点后六位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">x+y = <span class="hljs-number">0.300000</span><br><span class="hljs-number">0.3</span> = <span class="hljs-number">0.300000</span><br></code></pre></td></tr></table></figure><p>输出小数点后20位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-type">float</span> x = <span class="hljs-number">0.1</span>;<br>    <span class="hljs-type">float</span> y = <span class="hljs-number">0.2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x+y = %.20f\n&quot;</span>, x+y);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0.3 = %.20f\n&quot;</span>, <span class="hljs-number">0.3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果输出，可以发现并不是完全相等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">x+y = <span class="hljs-number">0.30000001192092895508</span><br><span class="hljs-number">0.3</span> = <span class="hljs-number">0.29999999999999998890</span><br></code></pre></td></tr></table></figure><p>所有关于钱的数据，是不允许使用这种可变浮点FLOAT的，比如在Java中可用BIGDECIMAL。</p><h3 id="fixed-point-precision-numbers">1.3 Fixed-Point PrecisionNumbers</h3><p><strong>- Examples: NUMERIC, DECIMAL</strong></p><p>这些是具有任意精度和比例的数值数据类型。它们通常以精确的、可变长度的二进制表示形式存储(几乎像字符串一样)，以及附加的元数据，这些元数据将告诉系统数据的长度和小数点应该在哪里。当舍入错误不可接受时，使用这些数据类型，但DBMS为获得这种准确性付出了性能代价。</p><p>Example1: PG中NUMERIC的表示形式</p><figure><img src="image-20220120125839569.png" alt="Numeric-Postgres" /><figcaption aria-hidden="true">Numeric-Postgres</figcaption></figure><p>Example2: MySQL中NUMERIC的表示形式</p><ul><li>数据多少位/权重/指数/正负零/指针指向char，是一个字符串 <imgsrc="image-20220120130054267.png" alt="Numeric-MySQL" /></li></ul><h3 id="variable-length-data">1.4 Variable-Length Data</h3><p><strong>- Examples: VARCHAR, VARBINARY, TEXT, BLOB</strong></p><p>这些表示任意长度的数据类型。它们通常与一个记录字符串长度的头文件一起存储，以方便跳转到下一个值。它还可以包含数据的校验和。</p><p>大多数DBMS不允许元组的大小超过单个页面的大小。那些将数据存储在一个特殊的“溢出”页面上，并让元组包含对该页面的引用的对象。这些溢出页可以包含指向其他溢出页的指针，直到可以存储所有数据为止。</p><p>有时会存储超长的数据，可能比数据库的一个页还长。这种情况通常使用溢出页 来存储数据。如果数据特别长，会单开辟一个页进行存储。 <imgsrc="image-20220120132318675.png" alt="TUPLE" /></p><p>不同的数据库触发溢出页的条件也有所不同：</p><ul><li>Postgres：数据大于2KB（一个页6KB）</li><li>MySQL: Overflow（大于1/2个页，一个页18 KB）</li><li>SQL Server: Overflow（大于整个页，一个页最少要存一行数据）</li></ul><p>如果溢出页也没存下？向后添加溢出页。但是尽量不要存储过长的数据，存取一次磁盘只能拿到一页的数据。如果存储图片，需要存储url，不要直接存储图片数据。<img src="image-20220120132347095.png" alt="TUPLE" /></p><p>也可以将很大的数据存储到外部文件，系统或者别的软件可能修改它，数据库无法保证这个文件没有被修改过。更好的方法是用户根据业务自行管理链接到数据库的外部文件。</p><p>有些系统允许您将这些大的值存储在一个外部文件中，然后元组将包含一个指向该文件的指针。例如，如果数据库正在存储照片信息，DBMS可以将照片存储在外部文件中，而不是让它们占用DBMS中的大量空间。这样做的一个缺点是DBMS不能操作这个文件的内容。因此，不存在持久性或事务保护。</p><h3 id="dates-times">1.5 Dates &amp; Times</h3><p><strong>- Examples: TIME, DATE, TIMESTAMP</strong></p><p>日期/时间的表示因系统而异。通常，这些被表示为某个单位时间(微/毫秒)Unix时代以来的秒数。</p><h4 id="system-catalogs">SYSTEM CATALOGS</h4><blockquote><p>为了使DBMS能够破译元组的内容，它维护一个内部编目来告诉它关于数据库的元数据。元数据将包含关于数据库有哪些表和列以及它们的类型和值的顺序的信息。大多数DBMS将它们的目录以它们用于表的格式存储在自己内部。它们使用特殊的代码来“引导”这些目录表。</p></blockquote><p>存储系统的元数据，一般都当做系统表存储起来，不需要其他数据存储的形式，如：</p><ul><li>表结构 行结构 索引 视图</li><li>用户 权限</li><li>内部统计信息</li></ul><p>几乎所有的数据库都自己管理catalog，以表的形式自己存储自己。一般的数据库中都有一张<strong>INFORMATION_SCHEMA</strong>表，其中存储着数据库中各种元信息。</p><p>查看数据库中表结构的原信息命令（查看当前数据库中的表）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- SQL-92</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br>  <span class="hljs-keyword">FROM</span> INFORMATION_SCHEMA.TABLES<br><span class="hljs-keyword">WHERE</span> table_catalog <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;&lt;db name&#x27;</span><span class="hljs-operator">&gt;</span>;<br><br><span class="hljs-comment">--Postgre</span><br>\d;<br><br><span class="hljs-comment">-- MySQL</span><br><span class="hljs-keyword">SHOW</span> TABLES;<br><br><span class="hljs-comment">--SQLite</span><br>.tables<br></code></pre></td></tr></table></figure><h2 id="数据库类型">2.数据库类型</h2><h3 id="oltp">2.1 OLTP</h3><p>在线事务处理：快速读写数据量很小的数据，往往意味着高并发（用户使用）</p><p>OLTP工作负载的特点是快速、短时间运行的操作、一次操作单个实体的简单查询和重复操作。OLTP工作负载通常会处理更多的写操作而不是读操作。</p><p>-Example:Amazon店面。用户可以将东西添加到购物车中，可以进行购买，但这些行为只会影响他们的账户</p><h3 id="olap">2.2 OLAP</h3><p>在线分析处理：复杂查询，读取大量数据并做一些复杂计算（公司使用）</p><p>OLAP工作负载的特点是长时间运行、复杂的查询和读取数据库的大部分内容。在OLAP工作中，数据库系统从OLTP端收集的现有数据中分析和导出新数据。</p><p>-Example: Amazon计算这些地理位置在一个月内购买最多的五件商品</p><h3 id="htap">2.3 HTAP</h3><p>HTAP是事务处理与分析处理的混合型数据库(Hybird Transaction +Analytical Processing)</p><p>事务型的倾向于写，分析性的越集中于读 <imgsrc="image-20220120134856976.png" alt="Database Workloads" /></p><p>HTAP没有出现时的通常做法：先从OLTP数据库中抽取数据做ETL，再放进数据仓库进行分析，最后把分析的结果写回到OLTP供用户查询。</p><p>HTAP的出现可以兼顾这两种工作情况，不必进行数据移动，节约资源与空间</p><figure><img src="image-20220120135229862.png" alt="Bifurcated Environment" /><figcaption aria-hidden="true">Bifurcated Environment</figcaption></figure><h5 id="行列存储">行列存储</h5><p>关系模型没有规定我们数据要按行存储（在底层），用户只是想按行查找，所以数据页中不一定一个Tuple是一行。</p><p>例： <img src="image-20220120135754433.png" alt="EXAMPLE" /></p><p><strong>OLTP语句：</strong></p><p>1.查询页面的更新记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> P.<span class="hljs-operator">*</span>, R.<span class="hljs-operator">*</span><br>  <span class="hljs-keyword">FROM</span> pages <span class="hljs-keyword">AS</span> P<br>  <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> revisions <span class="hljs-keyword">AS</span> R<br>    <span class="hljs-keyword">ON</span> P.latest <span class="hljs-operator">=</span> R.revID<br>  <span class="hljs-keyword">WHERE</span> P.pageID <span class="hljs-operator">=</span> ? <br></code></pre></td></tr></table></figure><p>2.用户更新资料</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mssql">UPDATE useracct<br>  SET lastLogin = NOW(),<br>      hostname = ?<br>  WHERE userID = ?<br></code></pre></td></tr></table></figure><p>3.新增更新记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> revisions<br><span class="hljs-keyword">VALUES</span>(?,?...,?)<br></code></pre></td></tr></table></figure><p><strong>OLAP语句:</strong></p><p>做复杂分析操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(U.lastLogin),<br>        EXTACT(<span class="hljs-keyword">month</span> <span class="hljs-keyword">FROM</span> U.lastLogin) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">month</span><br>        <span class="hljs-keyword">FROM</span> useracct <span class="hljs-keyword">AS</span> U<br>      <span class="hljs-keyword">WHERE</span> U.hostname <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%.gov&#x27;</span><br>      <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>        EXTACT(<span class="hljs-keyword">month</span> <span class="hljs-keyword">FROM</span> U.lastLogin)<br></code></pre></td></tr></table></figure><h2 id="数据存储模型">3.数据存储模型</h2><p>在页面中存储元组一般有行存和列存两种方法</p><h3 id="nsm">3.1 NSM</h3><p>如果一行是一个存储单位，就叫做n-ary storage model（NSM)</p><p>n-ary存储模型中，DBMS将单个元组的所有属性连续存储在单个页面中，因此NSM也被称为“行存储”。这种方法对于OLTP工作负载非常理想，在这种负载下，请求需要大量插入，事务往往只操作单个实体。它是理想的，因为它只需要一次获取就能够获得单个元组的所有属性。</p><p>一个单独的Tuple，保存着一组属性，组成了一组行记录。这种数据存储结构，按行存储更适合OLTP。<img src="image-20220120140817303.png" alt="NSM" /></p><figure><img src="image-20220120140824731.png" alt="NSM" /><figcaption aria-hidden="true">NSM</figcaption></figure><figure><img src="image-20220120140914969.png" alt="NSM" /><figcaption aria-hidden="true">NSM</figcaption></figure><p>列存更适合OLAP： <img src="image-20220120141030548.png"alt="NSM" /></p><p>如果是行存储，无用的数据也需要取出并解析： <imgsrc="image-20220120141115810.png" alt="NSM" /></p><h4 id="行存优点">行存优点</h4><ul><li>可以快速插入，更新和删除</li><li>对整行数据查询支持地比较好</li></ul><h4 id="行存缺点">行存缺点</h4><ul><li>不适合扫描表的大部分和/或属性的子集。这是因为它会获取处理查询不需要的数据，从而污染缓冲池</li></ul><h3 id="dsm">3.2 DSM</h3><p>拆开存储，通俗来讲叫做列存，一个tuple存的是一列，列存是分析友好的。</p><p>在分解存储模型中，DBMS将所有元组的单个属性(列)连续地存储在一个数据块中。因此，它也被称为“列存储”。这个模型非常适合OLAP工作负载，其中有许多只读查询，这些查询在表属性的一个子集上执行大的扫描。<img src="image-20220120141408669.png" alt="DSM" /></p><h4 id="tuple定义">Tuple定义</h4><figure><img src="image-20220120141546716.png" alt="Tuple Identification" /><figcaption aria-hidden="true">Tuple Identification</figcaption></figure><p>在使用列存储时，要将元组放回一起，有两种常见的方法：</p><ul><li><p><strong>固定长度偏移量</strong>：假设属性都是固定长度的，DBMS可以为每个元组计算属性的偏移量。当系统需要特定元组的属性时，它知道如何从offset跳转到文件中的该位置。为了适应变长字段，系统可以填充字段，使它们都具有相同的长度，或者使用一个接受固定大小的整数并将该整数映射到值的字典。</p></li><li><p><strong>嵌入式tupleid</strong>：在这里，对于列中的每个属性，DBMS存储一个元组id(例如:一个主键)。系统还会存储一个映射，告诉它如何跳转到每个具有该id的属性。注意，这个方法有很大的存储开销，因为它需要为每个属性条目存储一个tupleid。</p></li></ul><h4 id="dsm优点">DSM优点</h4><ul><li>减少了查询执行过程中浪费的工作量，因为DBMS只读取该查询所需的数据</li><li>支持更好的压缩，因为相同属性的所有值都是连续存储的</li></ul><h4 id="dsm缺点">DSM缺点</h4><ul><li>由于元组分割/拼接，点查询、插入、更新和删除速度较慢</li></ul><p><br/></p><blockquote><p>updated: 2021-07-03</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;database-storage-i&quot;&gt;Database Storage I&lt;/h1&gt;
&lt;h2 id=&quot;存储分层&quot;&gt;1. 存储分层&lt;/h2&gt;
&lt;p&gt;大部分数据库中的数据是在硬盘中的，用户操作数据时需要把数据加载到内存中，最后将修改后的数据重新写入硬盘。数据库存储模</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Join Algorithms</title>
    <link href="https://chakkk309.github.io/2022/03/19/joinalgorithms/"/>
    <id>https://chakkk309.github.io/2022/03/19/joinalgorithms/</id>
    <published>2022-03-18T16:00:00.000Z</published>
    <updated>2022-08-26T16:55:37.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="join-algorithms">Join Algorithms</h1><span id="more"></span><h4 id="为什么需要join连表呢">为什么需要join连表呢？</h4><p>关系型模型在存储时会按照连接关系分别存储，在取用数据的时候就需要join算子按照连接关系将数据重组起来。</p><h4 id="连接算法">连接算法</h4><p>本节主要研究<code>inner equijoin</code>算法（内连接且用相等谓词）。在查询计划中，join的一个原则是尽量把小表放在左侧，称其为外表或驱动表。</p><h4 id="join算子">Join算子</h4><p>SQL和逻辑计划：</p><center><img src="image-20220216104347403.png" style="zoom:50%; text-align:center" /></center><p>主要从两个方面来研究算子：output &amp;&amp; cost analysiscriteria。output决定了算子向上级输出的数据是什么；而开销模型则意味着不同的算法的开销，决定使用什么样的join方法实现。</p><h3 id="operator-output">Operator Output</h3><p>如果R表中的数据r（<span class="math inline">\(r \epsilonR\)</span>）和S表中的数据s（<span class="math inline">\(s \epsilonS\)</span>）匹配成功，r和s则连接成为一条新的tuple。而此时的Output会根据SQL处理模型，存储模型以及SQL需要的数据不同，输出不同的数据。</p><p>1.直接输出数据，又叫提前物化（Early Materialization）</p><p>执行join后向上输出的是连接后的一整行数据，优点是其他子算子不需要再回表了，无论想要哪个字段都可以立即得到。</p><p>对于一个SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> R.id, S.cdate<br>  <span class="hljs-keyword">FROM</span> R JPIN S<br>    <span class="hljs-keyword">ON</span> R.id <span class="hljs-operator">=</span> S.id<br> <span class="hljs-keyword">WHERE</span> S.value <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><center><img alt="Early Materialization" src="image-20220216105314271.png" style="zoom:50%;" /></center><p>2.输出record ID，又叫推迟物化（Late Materialization）</p><p>输出的不是完整的行数据，只是输出了行id，如果上级算子需要S表日期时，就需要通过行id回表查找。</p><center><img alt="Late Materialization" src="image-20220216105439174.png" style="zoom:50%;" /></center><h3 id="cost-analysis-criteria">Cost analysis criteria</h3><p>开销模型，假设：</p><ul><li>R表中有M页，m条tuple</li><li>S表中有N页，n条tuple</li></ul><p>如何分析开销呢？按照处理连接算法需要多少次磁盘IO来估计开销，相比于读取内存或CPU计算次数来说，磁盘IO的数量级比较大。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> R.id, S.cdate<br>  <span class="hljs-keyword">FROM</span> R <span class="hljs-keyword">JOIN</span> S<br>    <span class="hljs-keyword">ON</span> R.id <span class="hljs-operator">=</span> S.id<br> <span class="hljs-keyword">WHERE</span> S.value <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>用以上SQL为例，分析不同的算法对于连表的开销。</p><h2 id="笛卡尔积">笛卡尔积</h2><p><span class="math inline">\(R\bowtie S\)</span>表示两个表进行join操作，在SQL语句中是最常见的算子，需要小心谨慎去优化，比较耗时且容易出错。</p><p>连表最容易想到的实现方法是<span class="math inline">\(R\timesS\)</span>，即两个表进行笛卡尔积，列举出一个巨大的表，再使用谓词进行筛选。这种方法中间的结果集是非常大的，效率非常低效。除了笛卡尔积外，还有几种降低连表开销的算法：</p><h2 id="nested-loop-join">Nested Loop Join</h2><h3 id="simplestupid-nested-loop-join">Simple/Stupid Nested LoopJoin</h3><p>简单嵌套循环是一个二重循环，一般使用R表为外表，S为内表。</p><p>为何小表做外表呢？面向磁盘的数据库中，所谓的小表一般指的是文件页数少的，虽然R表行数多，但是它的表窄，页数少，遍历R需要的磁盘IO次数就较小。</p><center><img src="image-20220216105948926.png" style="zoom:50%;" /></center><center><img alt="Simple Nested Loop Join" src="image-20220216110354826.png" style="zoom:50%;" /></center><p>为什么这个算法效率不高？</p><p>对于R表中的每一行数据，都会扫描一次S表。对于这样的重复遍历，数据库的缓存池完全没有起到作用。比如S有三个页，缓存池中只能存储一个页，S会将缓存池灌满并一个个淘汰，当遍历到R表的第二行，S的第一行数据早已不存在于缓存池中了。嵌套循环的总体开销为<span class="math inline">\(M + (m \cdot N)\)</span>。</p><p>假设R表中M=1000页， m=100000条数据；S表中N=500， n=40000</p><p>代价分析：代入公式得，<span class="math inline">\(M + (m \cdot N)=1000 + (100,000 \cdot 50) = 50,001,000\IO_S\)</span>。假设读取磁盘IO的时间为 0.1 ms/IO，总用时约为1.3小时。</p><p>如果将较小的表S作为外表，总体开销为 <span class="math inline">\(N +(n \cdot M) = 500 + (40000 \cdot 1000) = 40,000,500\IO_S\)</span>，约花费1.1小时。</p><h3 id="block-nested-loop-join">Block Nested Loop Join</h3><p>设计思想是按block（页）进行遍历，进行四层嵌套循环：先把R表第一页读进缓冲池，再把S表第一页读进，在内部将两个页交叉匹配，然后把S表第一页淘汰，换其他的页继续计算。</p><center><img alt="Block Nested Loop Join" src="image-20220227232015339.png" style="zoom:50%;" /></center><p>总体开销为 <span class="math inline">\(M + (M \cdotN)\)</span>。效率提高了一些，虽然免不了从头到尾遍历R表，M个页的IO是少不了的。但是对于S表遍历的次数从m变为M次。即从遍历R表的tuple数变为遍历R表的页数次。</p><p>假设R表中M=1000页， m=100000条数据；S表中N=500， n=40000</p><p>代价分析：代入公式算得，<span class="math inline">\(M + (M \cdot N)=1000 + (1000 \cdot 50) = 501,000\ IO_S\)</span>。假设读取磁盘IO的时间为0.1 ms/IO，总用时约为50秒，性能提升几百倍。</p><p>如果可以给Join开B个页的内存，如何最大化的利用内存来提升性能呢？</p><p>有一个页要留作输出缓存，剩余B-1个页做为输入缓存。应该多缓存R还是多缓存S呢？</p><p>分配原则：多缓存左表（外表）为B-2页，只留一个页作为内表，伪代码为：</p><center><img src="image-20220227233311476.png" style="zoom:50%;" /></center><p>这种方法总体开销为 <span class="math inline">\(M + ([M / (B-2)] \cdotN)\)</span>。B-2页的缓存，把R表遍历几次。M的遍历次数是无法避免的，尽量把拉取N表的遍数降低，尽量多缓存外表。</p><p>如果缓存足够大（B&gt;M+2)，整个外表都能进入缓存，需要多少次IO呢？这是最理想的情况，开销为<spanclass="math inline">\(M+N\)</span> 为<span class="math inline">\(1500\IO_S\)</span>，仅用时0.15秒。</p><p>问题：嵌套循环无论如何都需要遍历外表，也就是总要遍历N次。需要遍历寻找匹配的id，为什么需要遍历？因为不存在索引，只能从头扫尾扫描表。如果内表存在索引，就不需要一遍遍遍历了，可以走索引去查S表。</p><h3 id="index-nested-loop-join">Index Nested Loop Join</h3><center><img alt="Index Nested Loop Join" src="image-20220227234342254.png" style="zoom:50%;" /></center><p>使用索引的循环嵌套，也叫lookupjoin。拿着R表中的每一行数据到内表中做查询，如果存在索引，就直接走<code>S.id</code>这条索引（B+树）。</p><p>B+树的层级与度不是固定的，不同的索引结构不一样，故开销不太好估算。假设每走一次索引，需要C个磁盘IO（包括根节点与叶子节点等），开销为<spanclass="math inline">\(M+(m\cdot C)\)</span>。只需要m次的索引查询。</p><p>总结：</p><ul><li>尽量让小表作为外表</li><li>需要尽量缓存外表，缓存内表再大都会有缓存重刷的问题。</li><li>尽量使用索引</li></ul><h2 id="sorted-merge-join">Sorted-merge Join</h2><p>分为两个阶段：阶段一为排序，阶段二为归并。</p><p>伪代码如下：第一行排序，剩下的为merge内容</p><center><img src="image-20220227235214838.png" style="zoom:50%;" /></center><p>例：</p><center><img alt="Sort Merge Join" src="image-20220227235355655.png" style="zoom:80%;" /></center><p>此时出现问题：此时S的游标要进行回退。S走到头了本次循环结束。</p><p>R表的排序开销：<span class="math inline">\(2M\cdot(1+[\log_{B-1}[M/B]])\)</span>，S表的排序开销：<spanclass="math inline">\(2N\cdot(1+[\log_{B-1}[M/B]])\)</span>，归并开销：<spanclass="math inline">\((M+N)\)</span>，总开销为三者之和。</p><p>例：假设对于一个数据库来说，R表中: M=1000页,m=100000条数据；S表中：N=500,n=40000，假设B=100，100页缓存用来做排序。</p><p>代入公式得，<span class="math inline">\(Sort Cost(R) = 4000\ IO_S,Sort Cost(S) = 2000\ IO_S,Merge Cost = 1500\IO_S\)</span>，一共为7500次IO，总用时约为0.75秒。</p><p>问题：可能会出现退化的情况下，如果两个表的id全部相等，就会退化为stupidnext loop join了，开销为<span class="math inline">\((M\cdot N) + sortcost\)</span>。</p><p>这种方法什么时候最有效呢？已经排好序的状态下极大地节省开销（下一级sort算子已经排好序了或读表时按照索引去读）；另一种情况是结果要求输出数据是要排好序的状态，可以考虑先排序再做mergejoin。</p><p>B+树点查询的时间复杂度是<spanclass="math inline">\(\log_n\)</span>，随着数据越来越多查询速度会越来越慢。针对点查询，可以使用哈希索引。</p><h2 id="basic-hash-join">Basic Hash Join</h2><p>基础的哈希算法分为两部分，第一阶段进行Build，构建哈希表，把外表R作为哈希表；然后Probe，去S表中遍历扫描。</p><center><img src="image-20220228001503985.png" style="zoom:50%;" /></center><center><img alt="Hash Join" src="image-20220228001801572.png" style="zoom:50%;" /></center><p>R表中的key存的是连接列，value提前物化和推迟物化的问题，根据情况存储整行数据或者行id。</p><p><strong>Probe阶段的优化</strong>：创建一个布隆过滤器，这样就可以提前判断key是否存在于哈希表中。内表做了哈希，企图从找到key，发现却匹配不上。布隆过滤器的位置如下图，在B表去查找哈希之前提前进行判断。</p><center><img alt="Bloom filter" src="image-20220228002210626.png" style="zoom:50%;" /></center><p><strong>布隆过滤器</strong></p><p>插入RZA，插入GZA，查找Raekwno，查找ODB <div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="image-20220228002352893.png" /></div><div class="group-image-wrap"><imgsrc="image-20220228002422628.png" /></div></div><div class="group-image-row"><div class="group-image-wrap"><imgsrc="image-20220228002450165.png" /></div><div class="group-image-wrap"><imgsrc="image-20220228002616755.png" /></div></div></div></p><p>有时布隆过滤器会出现假阳性，不过问题不大，最后还是要到哈希表中去查询。</p><center><img src="image-20220228002708237.png" style="zoom:50%;" /></center><p>问题：如果没有足够的内存去存储整个哈希表怎么办？可能需要驱逐一些哈希表到硬盘中。</p><h2 id="grace-hash-join">Grace Hash Join</h2><center><img src="image-20220228002919573.png" style="zoom: 50%;" /></center><p>Grace是一种数据库一体机，内部使用了grace 哈希join方法。</p><center><img src="image-20220228003129697.png" style="zoom:67%;" /></center><figure><img src="image-20220228003240174.png" alt="image-20220228003240174" /><figcaption aria-hidden="true">image-20220228003240174</figcaption></figure><p>如果一个block也非常大，应该怎么解决？</p><p>继续哈希，直到足够小的块。</p><center><img alt="" src="image-20220228003345557.png" style="zoom:50%;" /></center><center><img alt="recursive partitioning" src="image-20220228003533296.png" style="zoom:50%;" /></center><p>假设我们有足够的缓存池，花销为<spanclass="math inline">\(3(M+N)\)</span>。PartitioningPhase为读写两个表为<span class="math inline">\(2(M+N)\ IO_S\)</span>，Probing阶段只需要读表，为<span class="math inline">\(M+N\IO_S\)</span>，需要4500次IO，约0.45秒。为啥需要两遍？先读出再写回。</p><p>思考：如果DBMS知道外表多大，可以使用静态不扩容的hash表，反之使用动态扩容哈希表。</p><p><strong>Join算法开销比较</strong></p><center><img src="image-20220228004404188.png" style="zoom: 50%;" /></center><p>哈希是比较好的一种方法，但是也存在一些特例：数据是倾斜的，哈希碰撞，可能sorting会比较好一点；输出结果需要进行排序时使用merge好一点。一般数据库的优化器会在hash和merge join之间进行选择。OLAP中用嵌套循环比较少。</p><p><br/></p><blockquote><p>update: 2022-02-28</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;join-algorithms&quot;&gt;Join Algorithms&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hash Table</title>
    <link href="https://chakkk309.github.io/2022/03/19/hashtables/"/>
    <id>https://chakkk309.github.io/2022/03/19/hashtables/</id>
    <published>2022-03-18T16:00:00.000Z</published>
    <updated>2022-08-26T16:54:40.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希表">1.哈希表</h1><p>哈希表的本质是存储了键和值的无序的关联数组，是可重复的map。哈希表对于一个给定的key执行哈希函数，输出一个整数。这个值就是键值对在表中的位置。</p><p>空间复杂度为<span class="math inline">\(O(n)\)</span>，哈希表的空间和存储的数据量是线性相关的；平均时间复杂度为<spanclass="math inline">\(O(1)\)</span>，对一个键算哈希直接就能找到这个key在数组中的位置；最坏时间复杂度为<spanclass="math inline">\(O(n)\)</span>，所有key的哈希值都一样，这些key全部冲突，它们都存储在一个槽（bucket）里，性能就和链表数组差不多了。</p><p>一个哈希表的实现包括以下两部分：</p><ul><li><p><strong>哈希函数</strong>（Hash Function）</p><p>哈希函数用于计算桶或槽数组的索引。key取值范围可能是非常大的，但哈希表的槽是比较少的。哈希函数将一个大的键空间映射到一个较小的域。</p><p>需要考虑快速执行和碰撞率（fast vs. collision)之间的权衡。往往速度比较快的哈希函数更容易碰撞，而“完美”的哈希函数虽然没有碰撞，但会花费非常长的计算时间。设计的关键是如何在两者间保持平衡。</p></li><li><p><strong>哈希方案</strong>（Hashing Scheme）</p><p>设计一些结构用以如何处理哈希后的键冲突。需要考虑在分配一个大哈希表以减少冲突 和 在冲突发生时必须执行额外的指令之间的权衡。</p></li></ul><h1 id="哈希函数">2.哈希函数</h1><p>哈希函数接受任何键作为输入，最后返回该键的整数表示。函数的输出是确定性的，即相同的键应该总是生成相同的哈希输出。</p><p>DBMS不需要使用加密安全的哈希函数(例如 <code>SHA-256</code>)，因为不需要担心保护密钥的内容，函数主要在内部使用这些哈希函数。这样信息就不会泄露到系统之外。一般来说，我们只关心哈希函数的速度和碰撞率。</p><p>常用的哈希函数一般有：CRC-64(1975):用于底层通信和校验、MurmurHash(2008)、Google CityHash(2011)、FacebookXXHash(2012)、Google FarmHash(2014)。下图是这些哈希函数的Corei7上的表现，可以看到随着keysize的增长，各函数吞吐量的变化（key越长性能越好）</p><center><img alt="hash function benmark" src="image-20220127220304130.png" alt="image-20220127220304130" style="zoom:40%;" /></center><h1 id="静态哈希表">3.静态哈希表</h1><p>静态哈希表是一个数组，可以存储所有的键值。</p><p>例：一个静态哈希表的长度为100，最简单的哈希函数就是把所有的key都%100，随后将它们落在数组中，<code>%100</code>这个操作保证了不管多大的数据进来都能找到他们的位置。</p><center><img alt="static hash" src="image-20220127214053847.png" alt="image-20220127214053847" style="zoom:50%;" /></center><p>静态哈希方案是指哈希表的大小是固定的。这意味着如果DBMS运行哈希表的存储空间不足，那么它就必须从头开始重建一个更大的哈希表，比较耗费资源。通常新建哈希表的大小是原来哈希表的两倍。减少比较次数的浪费，重点是要避免哈希键的冲突。通常使用两倍的槽数作为预期的元素数。</p><p>一下理想情况在现实中是不成立的：</p><ol type="1"><li>提前得知元素数量</li><li>每个键都是唯一的</li><li>存在一个完美的哈希函数， IF key1不等于key2， then hash(key1)不等于hash(key2)，即永远不会出现哈希碰撞</li></ol><p>重点讨论三种静态哈希函数：</p><h2 id="linear-probe-hashing">3.1 Linear Probe Hashing</h2><p>线性探测哈希，又叫开放地址哈希法，它是一个超大数组中存了一堆哈希槽。这是最基本的哈希方案，通常也是最快的，它使用数组槽的循环缓冲区。哈希函数将键映射到槽。当冲突发生时，线性搜索相邻的插槽，直到找到一个开放的可插入的插槽。对于查找，可以检查键散列所指向的槽，线性搜索，直到找到所需的条目(或者一个空槽，在这种情况下键不在表中)。</p><p>注意，必须将key存储在槽中，以便检查某个数据是否是所需的数据。删除则更加棘手。对于仅仅从槽中删除条目，必须非常小心，因为这可能会防止以后的查找查找已经放在现在空槽下面的条目。这个问题有两种解决方案:</p><p>如果遇到哈希碰撞，就把kv存到下一个槽里，一个槽/桶只能放一个kv/指针，插入算法例：</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="image-20220127220936782.png" alt="INSERT1" /></div><div class="group-image-wrap"><imgsrc="image-20220127221011346.png" alt="INSERT2" /></div></div><div class="group-image-row"><div class="group-image-wrap"><imgsrc="image-20220127221050468.png" alt="INSERT3" /></div><div class="group-image-wrap"><imgsrc="image-20220127221312658.png" alt="INSERT4" /></div></div></div><p>删除算法，要删除C：</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="image-20220127221424562.png" alt="DELETE1" /></div><div class="group-image-wrap"><imgsrc="image-20220127221450124.png" alt="DELETE2" /></div></div></div><p>但是查找D会出现问题，原来是有数据现在没有，可能会怀疑没有D：</p><p><strong>- Approach 1: Tombstone</strong></p><p>设置一个墓碑，类似于死亡标记，说明这个位置原来有数据，但是它被删除了，所以会接着向下一个位置寻找D。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="image-20220127221712094.png" alt="TOMBSTONE1" /></div><div class="group-image-wrap"><imgsrc="image-20220127221804810.png" alt="TOMBSTONE2" /></div></div></div><p><strong>- Approach 2: Movement</strong></p><p>对数据重新进行整理，但是需要进行有逻辑的整理。需要注意数据正确的位置，如果是环形链表需要注意B的位置。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="image-20220127222046966.png" alt="MOVEMENT1" /></div><div class="group-image-wrap"><imgsrc="image-20220127222102409.png" alt="MOVEMENT2" /></div><div class="group-image-wrap"><imgsrc="image-20220127222139681.png" alt="MOVEMENT3" /></div></div></div><h5 id="non-unique-keys-问题">NON-UNIQUE KEYS 问题</h5><p>在hashmap中是不允许有重复的键出现的，但在数据库的索引中是有可能有重复的键出现，有两种解决思路：</p><p><strong>- Choice 1: Separate Linked List</strong></p><p>不是用键存储值，而是存储一个指向单独存储区域的指针，该区域包含所有值的链表。</p><center><img alt="Separate Linked List" src="image-20220127222632528.png" alt="image-20220127222632528" style="zoom:50%;" /></center><p><strong>- Choice 2: Redundant Keys</strong></p><p>把值和键拼接在一块，当成一个新的键。将相同的键多次存储在表。</p><center><img alt="Redundant Keys" src="image-20220127222751707.png" alt="image-20220127222751707" style="zoom:50%;" /></center><h2 id="robin-hood-hashing">3.2 <strong>Robin Hood Hashing</strong></h2><p>”罗宾汉哈希“是开放地址哈希的一种扩展，旨在减少每个键从其在哈希表中的最佳位置(即它们被哈希到的原始槽)的最大距离。这种策略从“丰富”的key中窃取插槽，然后将它们给“贫乏”的key。在这种变体中，每个条目也记录了它们与最佳位置之间的“距离”。在每次插入时，如果被插入的键在当前槽中的最佳位置比当前条目的距离更远，将替换当前条目，并继续尝试插入表中更远的旧条目。</p><p>基本结构如下图，<code>[0]</code>是代表key A 被推了几格：</p><center><img src="image-20220127222904008.png" alt="image-20220127222904008" style="zoom:35%;" /></center><p>在插入C的时候发现C和A碰撞了：</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="image-20220127223048801.png" alt="EG1" /></div><div class="group-image-wrap"><imgsrc="image-20220127223113883.png" alt="EG2" /></div></div></div><p>在插入D的时候发生碰撞：</p><center><img src="http://r756b90r8.hb-bkt.clouddn.com/15445/06%20Hash%20Tables/image-20220127223148595.png" style="zoom:33%;" /></center><p>在插入E的时候发现碰撞，它把D的位置抢了：</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="image-20220127223227776.png" alt="EG1" /></div><div class="group-image-wrap"><imgsrc="image-20220127223312417.png" alt="EG2" /></div></div></div><h2 id="cuckoo-hashing">3.3 Cuckoo Hashing</h2><p>这种方法不是使用单个哈希表，而是维护多个具有不同哈希函数的表。</p><p>哈希函数是相同的算法(例如，XXHash,CityHash);它们通过使用不同的种子值为同一个键生成不同的哈希值。</p><p>当插入时，检查每个表，并选择一个有空闲槽的表(如果多个表有一个空闲槽，可以比较loadfactor之类的东西，或者更常见的是，选择一个随机的表。</p><p>如果没有表有空闲槽，我们选择(通常是随机的)并退出旧的条目，然后将旧条目重新散列到另一个表中。</p><p>在极少数情况下，可能会陷入一个循环。如果出现这种情况，可以使用新的哈希函数种子(不太常见)重建所有哈希表，或者使用更大的表(更常见)重建哈希表。</p><p>Cuckoo Hashing 保证了O(1)的查找和删除，但插入可能更昂贵。</p><p>有多个哈希表，这里以两个哈希表为例（两个哈希表有两个哈希函数）：</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="image-20220128150625315.png" alt="EG1" /></div><div class="group-image-wrap"><imgsrc="image-20220128150656325.png" alt="EG2" /></div></div></div><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="image-20220128150758494.png" alt="EG1" /></div><div class="group-image-wrap"><imgsrc="image-20220128150835920.png" alt="EG2" /></div></div></div><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="image-20220128150906362.png" alt="EG1" /></div><div class="group-image-wrap"><imgsrc="image-20220128150951549.png" alt="EG2" /></div></div></div><p><strong>思考</strong></p><p>前几种静态哈希函数的问题在于存储的元素数量有限，当需要存储的数据大于能够存储的元素个数，需要重新创建一个更大的哈希表，不能够动态伸缩。</p><h1 id="动态哈希方案">4.动态哈希方案</h1><p>静态哈希方案要求DBMS知道它想要存储的元素的数量。否则，如果需要增大/缩小表的大小，必须重建表。</p><p>动态哈希方案能够根据需要调整哈希表的大小，而不需要重建整个哈希表。这些方案以不同的方式执行这种调整，可以最大化读或写。</p><h2 id="chained-hashing">4.1 Chained Hashing</h2><p>拉链哈希是最常见的动态哈希方案。DBMS为哈希表中的每个槽维护一个桶的链表。散列到相同槽位的键被简单地插入到该槽位的链表中。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="image-20220128151807095.png" alt="EG1" /></div><div class="group-image-wrap"><imgsrc="image-20220128151841531.png" alt="EG2" /></div></div></div><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="image-20220128151904305.png" alt="EG1" /></div><div class="group-image-wrap"><imgsrc="image-20220128151925343.png" alt="EG2" /></div></div></div><p>-注：Java中的HashMap是拉链式哈希，但是第一个bucket里面只有一个值，是一个纯链表结构。数据多会导致链表很长，Java在1.8之后使用红黑树与链表结合。</p><p>​ Go中的Map中，第一个桶里有8个位置，如果满了会链接到一个溢出桶。</p><h2 id="extendible-hashing">4.2 Extendible Hashing</h2><p>可扩展哈希，改进的链列哈希，拆分桶而不是让链永远增长。这种方法允许哈希表中的多个槽位置指向同一个bucketchain。</p><p>左边的标志位【2】表示只看哈希值的前两个二进制位，会指向三个桶：第一桶只看第一位是0，第二桶看前两位是10，第三桶看前两位是11。</p><center><img src="image-20220128152655834.png"Mstyle="zoom:33%;" /></center><p>查找A，插入B，插入C。</p><center><img src="image-20220128152758600.png" style="zoom:50%;" /></center><p>一系列操作后发现桶满了，将全局的标志位改成3，槽从4个变为8个，将原来桶中的数据进行进行rehash：</p><center><img src="image-20220128153047519.png" style="zoom:40%;" /></center><p>再插入C：</p><center><img src="image-20220128153204895.png" style="zoom:40%;" /></center><p>重新平衡哈希表的核心思想是在拆分时移动桶项，并增加比特数来检查哈希表中的条目。这意味着DBMS只需要在分割链的桶中移动数据;所有其他桶都保持原样。</p><p>-DBMS维护一个全局和局部深度位计数，它决定在槽数组中查找bucket所需的位数</p><p>-当存储桶满时，DBMS将存储桶拆分并重新洗牌其元素。如果拆分桶的局部深度小于全局深度，则新桶将被添加到现有的槽位数组中。否则，DBMS将插槽数组的大小翻倍以容纳新的存储桶，并增加全局深度计数器。</p><h2 id="linear-hashing">4.3 Linear Hashing</h2><p>这个方案不是在桶溢出时立即拆分桶，而是维护一个拆分指针来跟踪下一个要拆分的桶。无论该指针是否指向溢出的桶，DBMS总是分裂。溢出标准由实现决定。</p><ul><li>当任何桶溢出时，通过添加一个新的槽项在指针位置拆分桶，并创建一个新的哈希函数</li><li>如果哈希函数映射到之前被指针指向的槽位，应用新的哈希函数</li><li>当指针到达最后一个槽位时，删除原来的哈希函数，并用一个新的哈希函数替换它</li></ul><p>四个哈希槽，有一个分裂指针，哈希函数为</p><center><img src="image-20220128153527529.png" style="zoom: 33%;" /></center><center><img src="image-20220128153719853.png" style="zoom:33%;" /></center><center><img src="image-20220128153806574.png" style="zoom:33%;" /></center><figure><img src="image-20220128154539295.png" alt="SUMMARY" /><figcaption aria-hidden="true">SUMMARY</figcaption></figure><p>哈希表几乎不用于范围查询，这是因为key在哈希后丢失了一些数据，也就失去了原来的顺序。且hash索引也同样不能排序，以及<code>like 'XXX%'</code>这类的模糊查询；同样也不支持最左前缀排序。</p><p>哈希索引多用于点查询，如<code>select age from table where age = 23</code>这类SQL语句，在不出现冲突的情况下，经过O(1)时间就可以找到相应的数据，查找效率比较高。如果非常不幸，哈希碰撞严重，查找效率就会变得极低。</p><p><br/></p><blockquote><p>update: 2022-02-13</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;哈希表&quot;&gt;1.哈希表&lt;/h1&gt;
&lt;p&gt;哈希表的本质是存储了键和值的无序的关联数组，是可重复的map。哈希表对于一个给定的key执行哈希函数，输出一个整数。这个值就是键值对在表中的位置。&lt;/p&gt;
&lt;p&gt;空间复杂度为&lt;span class=&quot;math inline&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Buffer Pool</title>
    <link href="https://chakkk309.github.io/2022/03/19/bufferpool/"/>
    <id>https://chakkk309.github.io/2022/03/19/bufferpool/</id>
    <published>2022-03-18T16:00:00.000Z</published>
    <updated>2022-08-26T16:55:09.106Z</updated>
    
    <content type="html"><![CDATA[<p>问题：存储引擎如何管理内存与磁盘间的数据流动？</p><p>buffer pool：在内存中开辟一片区域作为缓存，存储数据库文件。</p><h2 id="简介">1.简介</h2><p>DBMS负责管理数据在内存和在磁盘上的移动。</p><p>在大多数情况下，数据不能直接在磁盘中操作，任何数据库都必须能够有效地将磁盘上表示为文件的数据移动到内存中，以便使用。</p><p>缓存池存在于内存中，而且一定是比磁盘小的多。数据库的执行器想要读取2号页时，首先会查询缓存池中是否存在该页，如果有就读取，没有的话就需要从先加载索引页到缓存池，对应找到2号页的位置，将其加载到缓存池中，交给执行器进行数据解析。</p><center><img src="image-20220125005537858.png" alt="disk-oriented DB" style="zoom:80%;" /></center><p>另一方面，可以从时间和空间上来考虑这个问题：</p><p><strong>空间</strong></p><ul><li>空间上的控制指的是页在磁盘上的物理位置，也就是在磁盘的什么位置写入页</li><li>目标：保证经常使用的页在磁盘中的物理位置也是比较邻近的，使在磁盘上经常使用的页面在物理上尽可能靠近</li></ul><p><strong>时间</strong></p><ul><li>什么时候把页读到内存中，什么时候把页写入磁盘中</li><li>目标：最小化从磁盘中读取数据的开销，尽量减少从磁盘读取数据的数量</li></ul><h2 id="lock-latches">2. Lock &amp; Latches</h2><p>在讨论DBMS如何保护它的内部元素时，我们需要区分Lock和Latches</p><h4 id="locks">Locks</h4><ul><li><p>锁是一种高级的逻辑原语，它保护数据库的内容(例如行数据、表、数据库)不受其他事务的影响，在事务级别保护数据库的逻辑内容。如：对一个表上锁，这期间任何事务都不能操作该表。</p></li><li><p>在事务期间被持有，数据库系统可以向用户公开在运行查询时持有哪些锁</p></li><li><p>需要保证能够回滚</p></li></ul><h4 id="latchmutex">Latch（Mutex）</h4><ul><li><p>DBMS用于其内部数据结构(例如，哈希表，内存区域)的关键部分的一种低级保护原语，是一种底层的锁如：跟表相关的数据页加上的锁</p></li><li><p>仅在操作期间被持有，在线程级别保护数据库内部的数据结构</p></li><li><p>不需要保证回滚</p></li></ul><h2 id="缓存池">3. 缓存池</h2><p>缓存池是从磁盘读取页的内存缓存。它本质上是在数据库内部分配的一个大内存区域，用于存储从磁盘获取的页。</p><p>缓存池的组织形式：内存区域被组织为一个固定长度的page数组，数组中的每一个元素叫做帧（frame），缓存池里的一帧和磁盘上的一个页相对应。</p><center><img src="image-20220428222157638.png" alt="bufferpool" style="zoom:50%;" /></center><p>当DBMS请求一个页时，一个精确的副本被放置到缓冲池的一个帧中。当请求页时，数据库系统可以首先搜索缓存池。如果没有找到该页，则系统从磁盘中获取该页的副本。</p><p>怎么知道缓存池缓存了那些页呢？需要pagetable类似索引的结构以及其他方法，如下图在page3处增加了图钉标志，不要清除page3它之后还会有用处；或者对某个空位置加锁，预留位置读取特定的页。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="image-20220120143247987.png" alt="flag" style="zoom:40%;"/></div><div class="group-image-wrap"><img src="image-20220120143331428.png" alt="lock" style="zoom:40%;" /></div></div></div><h4 id="缓存池元数据">缓存池元数据</h4><p>缓存池必须维护某些元数据，以便有效和正确地使用：</p><ul><li><p><strong>page table</strong></p><p>页表（pagetable）是一个内存中的哈希表，用于跟踪当前内存中的页。它将页id映射到缓冲池中的帧位置。因为缓冲池中的页顺序不一定反映磁盘上的顺序，所以这个额外的间接层允许标识池中的页位置。页表还维护每页的额外元数据、脏标记和引脚/引用计数器。</p><p>注：不要将页表与页目录混淆，后者是数据库文件中从页id到页位置的映射。</p></li><li><p><strong>dirty-flag</strong></p><p>dirty-flag是由线程在修改页时设置的，这指示存储管理器必须将该页写回磁盘。</p></li><li><p><strong>pin/reference Counter</strong></p><p>用来跟踪当前访问该页面(读取或修改该页面)的线程数。线程在访问该页之前必须增加计数器。如果一个页的计数大于零，那么存储管理器就不允许从内存中删除该页。</p></li></ul><h4 id="内存分配策略">内存分配策略</h4><p>数据库中的内存根据两种策略分配给缓存池：</p><p><strong>全局策略</strong>：统一安排所有事物需要的所有数据页，缓存的位置。处理DBMS应该做出的有利于正在执行的整个工作负载的决策。它考虑所有活动事务，以找到分配内存的最佳决策。</p><p><strong>本地策略</strong>：为每一个事物需要缓存的文件页有单独的策略。将使单个查询或事务运行得更快，即使这对整个工作负载不利。本地策略将帧分配给特定的事务而不考虑并发事务的行为。</p><h2 id="缓存池优化策略">4. 缓存池优化策略</h2><h4 id="多缓存池">4.1 多缓存池</h4><p>DBMS可以为不同的目的维护多个缓冲池（即每个数据库的缓冲池，每个页面类型的缓冲池）。文件页是不一样的，有些是存储索引，有些是存储数据的。为不同存储分类使用不同的缓存池。同时也可以一个数据库实例使用多个缓存池，一个数据库一个缓存池或者一个页一个缓存池都可以。缓存池只有一个时，向缓存池添加数据时需要先把那个位置锁住，多个缓存池可以降低锁冲突和竞争。</p><p>具体的实现方法有两种：</p><p><strong>Object id</strong></p><p>记录哪条数据去了那个缓存池，例id=123存储在一号缓存池中，维护从object到特定缓存池的映射</p><center><img src="image-20220428223934250.png" alt="Object id" style="zoom:50%;" /></center><p><strong>Hashing</strong></p><p>对page id进行哈希，已选择要访问的缓存池</p><center><img src="image-20220428224003070.png" alt="Hashing" style="zoom:50%;" /></center><h4 id="预先抓取pre-fetching">4.2 预先抓取（PRE-FETCHING)</h4><p>DBMS还可以根据查询计划预取页来进行优化。在处理第一组页时，可以将第二组页预取到缓冲池中。</p><p><strong>全表扫描</strong></p><p>例：如果要进行全表扫描，需要将表中的数据从第0条到第N条全部遍历一遍，缓存池就知道需要将数据全部遍历。首先将0号页读到缓存池中，然后陆续是1号页，2号页…….在读1号页的时候，已经明确地知道接下来要读取的是2号页，那么在进行处理1号的同时，可以提前将0号页淘汰，2号和3号页读到缓存池中。执行器可以不必等待便可读取2和3号页，有点”先人一步“的意思。</p><center><img src="image-20220428225918009.png" alt="table scan" style="zoom:50%;" /></center><p><strong>索引扫描</strong></p><p>例：需要查找值在100到250之间的数据，索引大多是树状结构，所有的数据在叶子节点上，首先读取根节点，判断要读取左子树还是右子树，确定了范围就可以预先抓取3号页到5号页。</p><center><img src="image-20220428230238203.png" alt="index scan" style="zoom:67%;" /></center><p>这种方法是数据库管理系统(DBMS)在连续访问多个页面时常用的方法。</p><h4 id="扫描共享scan-sharing">4.3 扫描共享（SCAN SHARING）</h4><p>如果发现有两个事务同时读取一个表，则可以让他们同步扫描。</p><p>SQL A需要A和B join的结果，SQLB也需要该结果。A和B请求几乎同时到达数据库，如果没有进行优化，DBMS会进行两遍相同的查询并返回给AB。如果使用共享扫描，AB可以共享扫描结果。</p><p>扫描共享和结果缓存（result caching）是不同的，扫描共享中请求是并行的，可以在执行过程中就可以判断两个事务有共同的请求；而结果缓存是A先执行语句，将结果缓存，等到B执行的时候就可以直接读取缓存。</p><h5 id="同步扫描">同步扫描</h5><p>需要计算val这一列全部数据的值，所以需要全表扫描：</p><center><img src="image-20220428230434458.png" alt="syn scan" style="zoom:67%;" /></center><h4 id="buffer-pool-bypass">4.4 BUFFER POOL BYPASS</h4><p>旁路策略：扫描过来的数据不进内存池，直接放到内存中没有池化的区域，执行器使用后把这块内存进行GC。</p><p>好处：对没有必要加入缓存池的数据避免开销，不必考虑后续如何对它进行替换淘汰。当操作符需要读取磁盘上连续的大量页面时，这很可能是一次全表扫描操作，只读取一次就不再使用，这种情况可使用旁路策略。缓冲池旁路也可以用于临时数据(排序、连接)。Ajoin B 直接给用户不必放在内存池中。这种不进内存池的扫描方法被称为"LightScans"。</p><p><strong>OS pages cache</strong></p><p>操作系统读写磁盘时，对于文件页进行缓存。但这种时候一般需要操作系统绕过这层缓存，OS不知道缓存的策略，需要保存多久，什么时候淘汰。而且与数据本地的缓存还是冗余的，操作系统的页缓存需要bypass掉，大多数数据库使用直接I/O(O_DIRECT)来绕过操作系统缓存页，自己管理缓存。</p><p>问题：冗余存储页；不同的淘汰策略；失去对IO的控制，DB没法去优化IO。</p><h2 id="缓存替换策略">5. 缓存替换策略</h2><p>为什么需要进行替换呢？因为bufferpool的空间是有限的，要清空一部分帧来给新的文件页腾出空间，因此需要制定一些策略来驱逐内存中的旧页。</p><p>替换策略是DBMS实现的一种算法，它在需要空间时决定从缓冲池中删除哪些页。</p><p>设计目标：正确，不能把正在使用的页替换掉；准确，速度快，不能为了决定替换那一页使用很长时间的算法；缓存元数据的开销，元数据存储内容为哪些页在缓存池中哪些页不在，如果进行了页的替换，同时也需要维这些元数据。</p><h4 id="lru">5.1 LRU</h4><p>最近-最少使用算法(LEAST-RECENTLYUSED)：给每一个页都维护一个单独的时间戳，记录上次读取这个页是什么时间。驱逐调很久都没有被读过的文件页。</p><p>实现方式：使页面变成有序，减少淘汰的搜索时间，但这种方法排序的时间太长，效率较差。</p><h4 id="clock">5.2 CLOCK</h4><p>顺时针算法：它是一个模糊且快速，开销比较小的LRU改进算法。在CLOCK策略中，将页组织成一个循环缓冲区，每个页都有一个标志位ref。当这个页面被访问一次，就将ref设置为1。扫描检查时，如果页的ref为1，则将其减一，设为零，如果ref=0，则驱逐该页。</p><p>比如内存池中有四个页，做了一个环形的数据结构（内存中不是环形），每个页有一个标志位ref。取了一下page1，将其ref至1。时针转到1，ref清空但是不追逐。时针转到2，ref=0表示没有任何人读过，所以从内存中驱逐，替换成别的页page。</p><ol type="1"><li>每个页有一个标志位ref</li></ol><p><img src="image-20220503132710028.png" alt="clock-1" style="zoom:50%;" /></p><ol start="2" type="1"><li>执行器取了page1</li></ol><p><img src="image-20220503132823543.png" alt="clock-2" style="zoom:50%;" /></p><ol start="3" type="1"><li>将其ref设置为1，意味着有人读取了page1一次</li></ol><p><img src="image-20220503132900930.png" alt="clock-3" style="zoom:50%;" /></p><ol start="4" type="1"><li>此时有一个时针在转动，发现page1的ref为1，将其设置为0但是不清空。</li></ol><p><img src="image-20220503132932793.png" alt="clock-4" style="zoom:50%;" /></p><ol start="5" type="1"><li>将ref置0</li></ol><p><img src="image-20220503133122934.png" alt="clock-5" style="zoom:50%;" /></p><ol start="6" type="1"><li>时针转到page2的时候，ref为0，则清空page2的缓存</li></ol><p><img src="image-20220503133219260.png" alt="clock-6" style="zoom:50%;" /></p><ol start="7" type="1"><li>并再将page5的内容读进缓存池</li></ol><p><img src="image-20220503133252679.png" alt="clock-7" style="zoom:50%;" /></p><ol start="8" type="1"><li>驱逐page1</li></ol><p><img src="image-20220503133335312.png" alt="clock-8" style="zoom:50%;" /></p><h4 id="lru的问题">LRU的问题</h4><p>LRU和时钟替换策略有很多问题：</p><ul><li>对于sequentialflooding来讲性能是比较差的，最近使用的页面可能实际上是最不需要的页面。</li><li>如果做一个全表扫描，不知道要不要替换内存中的哪个页。</li></ul><p>例：sequential flooding情况下的LRU</p><ol type="1"><li>第一个SQL语句为点查询，从page0开始将数据读到内存池中</li></ol><center><img src="image-20220503133920418.png" alt="lru-1" style="zoom:50%;" /></center><ol start="2" type="1"><li>此时出现第二个SQL语句Q2，进行全表扫描</li></ol><center><img src="image-20220503134050627.png" alt="lru-2" style="zoom:50%;" /></center><ol start="3" type="1"><li>Q2进行线性扫描，此时缓存池已经装满</li></ol><center><img src="image-20220503134112451.png" alt="lru-3" style="zoom:50%;" /></center><ol start="4" type="1"><li>读取page3，按照LRU算法来看需要用page3来替换page0，此时内存池中的数据page0最有用，因为它刚刚被Q1点查询过，是热点数据，对于全表扫描来说，这些页都只扫描一次，它们的权重都是一样的。这种情况下说明，page0比page1和page2重要一些。</li></ol><center><img src="image-20220503134137166.png" alt="lru-4" style="zoom:50%;" /></center><ol start="5" type="1"><li>按照LRU算法使用page3替换掉page0</li></ol><center><img src="image-20220503134157363.png" alt="lru-5" style="zoom:50%;" /></center><ol start="6" type="1"><li>此时Q3再次进行点查询，可是缓存池内再也没有了page0，于是又到disk中再次读取page0。</li></ol><center><img src="image-20220503134230843.png" alt="lru-6" style="zoom:50%;" /></center><ol start="7" type="1"><li>用page0替换掉page1</li></ol><center><img src="image-20220503134254772.png" alt="lru-7" style="zoom:50%;" /></center><p>有三种解决方案可以改进LRU和CLOCK策略的缺点：</p><h4 id="lru-k">5.3 LRU-K</h4><p>LRU会记录每一个页上次的访问时间，驱逐最老的访问时间。改进策略为记住上K次的访问时间，如果K=5则会记录前五次的访问时间，从中计算出规律，用于预测页下次被访问的时间。</p><h4 id="localization">5.4 LOCALIZATION</h4><p>本地化策略，以事务或SQL语句为单位进行驱逐，这将减少每个查询对缓冲池的污染，即与本人相关的页可以驱逐，但是与别人相关的数据要慎重驱逐。</p><p>例：记录page1是Q1这条语句读过的，Q2执行是发现page1不仅被自己读过也被前面的语句读过，这个页出现的频率更高，将其保留。</p><h4 id="priority-hints">5.5 PRIORITY HINTS</h4><p>优先级提醒，执行器在执行的时候，可以给缓存池一些指示告诉缓冲池页面是否重要。对于树状的索引来讲，它的根节点更为重要，根节点的缓存不要去清理，基本上一开机就读到内存中，永远不清理。</p><p>例：</p><ol type="1"><li>SQL1插入数据</li></ol><center><img src="image-20220503145752398.png" alt="proprity hints-1" style="zoom:67%;" /></center><ol start="2" type="1"><li>SQL2查询数据</li></ol><center><img src="image-20220503145829478.png" alt="proprity hints-2" style="zoom:67%;" /></center><p>只要遍历索引，就必须从根节点开始，所以缓存根节点是非常有必要的。</p><h5 id="dirty-page">DIRTY PAGE</h5><p>什么是脏页？怎么将内存中文件的变化写回磁盘，而脏页就是修改了但是还没存到磁盘中的文件。</p><p>两种方法可以处理脏页：</p><ul><li>最快：删除缓冲池中未被脏化的任何页</li><li>最慢：将脏页写回磁盘，以确保其更改被持久化</li></ul><p>这两种方法说明了快速驱逐和脏页之间的权衡，如果这个脏页如果以后都用不到了，可以写回；如果这个脏页还要用到，就暂时先不写回磁盘。如果将脏页一直放在内存中，不写入磁盘，存在持久化的问题，大多数据库使用WAL方案解决脏页持久化。为了减少磁盘IO，需要定期将脏页刷盘，如果修改后断电了怎么办？其中WAL日志是先写入磁盘的。</p><h5 id="background-writing">BACKGROUND WRITING</h5><p>通过异步刷脏，DBMS可以周期性地遍历页表并将脏页写入磁盘。当一个脏页被安全地写入时，就可以驱逐这个脏页，或直接设置一个不是脏页的标志位，可能以后还有用处。此外，还要小心对待脏页和WAL之间的顺序，如果没有刷脏，那么至少需要将日志进行持久化，否则掉电将会失去数据。</p><h2 id="其他缓存数据">6. 其他缓存数据</h2><p>内存中除了保存元组和索引，还需要在内存池中保存其他的内容：</p><ul><li>Sorting +Join Buffers</li><li>Query Cache，缓存热点的SQL语句的执行结果。</li><li>Maintenance Buffers</li><li>Log Buffers</li><li>Dictionary Cache</li></ul><h3 id="conclusion">7. CONCLUSION</h3><p>数据库自己去处理缓存永远比操作系统帮助我们处理这些缓存要好，因为数据库知道哪一个页是做什么的，会不会再用到，而OS是不清楚这一点的。同时缓存池可以根据执行计划做一些优化，比如：驱逐，分配以及预抓取策略以提升效率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;问题：存储引擎如何管理内存与磁盘间的数据流动？&lt;/p&gt;
&lt;p&gt;buffer pool：在内存中开辟一片区域作为缓存，存储数据库文件。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;1.简介&lt;/h2&gt;
&lt;p&gt;DBMS负责管理数据在内存和在磁盘上的移动。&lt;/p&gt;
&lt;p&gt;在大多数情况下，数据不</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://chakkk309.github.io/2022/03/01/hello-world/"/>
    <id>https://chakkk309.github.io/2022/03/01/hello-world/</id>
    <published>2022-03-01T12:42:33.309Z</published>
    <updated>2022-08-25T19:24:59.148Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very
first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Query Optimization</title>
    <link href="https://chakkk309.github.io/2022/02/28/query-execution-optimization/"/>
    <id>https://chakkk309.github.io/2022/02/28/query-execution-optimization/</id>
    <published>2022-02-28T08:42:39.000Z</published>
    <updated>2022-08-27T13:57:23.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="query-execution-i">Query Execution <strong>I</strong></h1><figure><img src="image-20220302161405827.png" alt="Query Plan" /><figcaption aria-hidden="true">Query Plan</figcaption></figure><p>DBMS将SQL语句转换为查询计划。查询计划中的操作符被安排在一个树中。查询计划，也叫做查询树，有一些列操作符组成，它们按照一定的运算关系构成查询的一个执行方案。从形式上看是一颗二叉树，树叶是每个单表对象，两个树叶的父节点是一个连接操作符。据从这棵树的叶结点流向根结点。树中根节点的输出是查询的结果。通常操作符是二进制的(1-2个孩子)。同一个查询计划可以以多种方式执行。</p><h2 id="processing-model">1. Processing Model</h2><p>执行模型是用来定义系统执行计划是怎么计算的，它指定查询计划的计算方向以及操作符之间传递的数据类型。处理模型有不同的模型，不同的workload在设计上会有一些trade-off。</p><p>这些模型还可以实现为从顶到底或从底到顶调用操作符。虽然从上到下的方法更为常见，但从下到上的方法可以更严格地控制管道中的缓存/寄存器（caches/register），这里介绍三种模型：</p><h4 id="approach1-iterator-model">Approach#1: Iterator Model</h4><p>迭代器模型，也称为Volcano或Pipeline模型，是最常见的处理模型，几乎每个(基于行的)DBMS都使用它。</p><p>迭代器模型通过为数据库中的每个操作符实现Next函数来工作。查询计划中的每个节点调用子节点上的Next，直到到达叶节点，叶子节点开始向其父节点发出tuple以进行处理。在检索下一个元组之前，对每个tuple进行尽可能多的计划处理。这在基于磁盘的系统中非常有用，它允许在访问下一个元组或页面之前充分使用内存中的每个tuple。</p><p>执行计划中每个算子都要实现一个<code>Next()</code>方法。每一次父算子会调用Next方法，子算子都会返回一行数据给父算子，没有数据时会返回null；如果当前算子是父算子，它将在循环中不断地调用子算子的Next方法，获取数据进行处理。</p><p>迭代器模型如下图所示：</p><figure><img src="image-20220302163542147.png" alt="Iterator Model" /><figcaption aria-hidden="true">Iterator Model</figcaption></figure><ol type="1"><li><p>循环调用子算子的next方法，每拿到子算子的tuple，就向外projection（输出）</p></li><li><p>循环调用左孩子的next方法，使用外表去构建一个哈希表，此时projection是阻塞的，需要等待该步骤的emit方法执行才能获取数据；</p><p>再循环调用右孩子的next方法，从S表中不断获取数据，与谓词条件进行判断，如果匹配，就将该数据与哈希表中的数据进行匹配。</p></li></ol><p>在对Next的每次调用中，操作符要么返回单个tuple，要么返回空标记(如果没有更多tuple可发出)。该操作符实现了一个循环，该循环在其子对象上调用Next来检索它们的tuple，然后对它们进行处理。这样，在父对象上调用Next，在其子对象上调用Next。作为响应，子节点将返回父节点必须处理的下一个tuple。迭代器模型允许流水线操作，DBMS可以在检索下一个tuple之前通过尽可能多的操作符处理一个tuple。查询计划中为给定tuple执行的一系列任务称为管道。</p><p>几乎所有的数据库都实现了火山模型及其变种。有一些算子会有阻塞的阶段，需要子算子返回全部的数据。比如：joins，subqueries，order by操作，在这些阶段不能向上吐出数据。orderby不能流式计算，子算子需要获取所有数据后一起进行排序，再将排好的结果返回给上一级。使用火山模型，输出控制是比较容易实现的，如<code>limit 100</code>，不需要底层读表的算子需要读取多少行，直接从最顶层控制出口即可，因为算子一旦拥有了所需的所有tuple，就可以在它的子(或子)算子停止调用Next。不难看出，火山模型中使用大量的函数调用和返回值传输数据，大量的函数调用会导致性能问题。</p><h4 id="approach2-materialization-model">Approach#2: MaterializationModel</h4><p>物化模型，一次性输出输出全部的数据。如：判断一个属性是否大于100，把所有的数据一次性拿出，然后返回判断后的结果。</p><figure><img src="image-20220302164924479.png" alt="Materialization Model" /><figcaption aria-hidden="true">Materialization Model</figcaption></figure><p>每一个算子都是一个方法，返回一个数组。数据的操作单位是一个包含全部数据的数组，最后整个输出。每个算子只调用一次，做完全部的判断。</p><p>有一些OLTP数据比较适合这个模型，它们一般都是点查询，只涉及到几行数据，所以数据集也比较小；而OLAP类型查询中庞大的结果集就不怎么适用了。</p><h4 id="approach3-vectorization-model">Approach#3: VectorizationModel</h4><p>火山模型和物化模型都有一些问题，向量化模型有点向它们的结合。它也像火山模型一样有Next方法，但是它每次返回的不是一个singletuple，而是一批 batch tuple。</p><figure><img src="image-20220302165555099.png" alt="Vectorization Model" /><figcaption aria-hidden="true">Vectorization Model</figcaption></figure><p>与迭代器模型一样，向量化模型中的每个操作符都实现了Next函数。然而，每个操作符发出的是一批数据(即向量)，而不是单个tuple。向量化模型与迭代器模型非常相似，除了在每个操作符处，输出缓冲区与期望的发送大小相比较。如果缓冲区更大，则发送一个tuple批处理。</p><p>n是设置的数据，一批一个数据，需要调用1万次，如果一批返回10条数据，那么只用函数调用1000次，函数调用次数大大减少。</p><p>这种方法对于OLAP类型数据库比较友好，能够减少函数调用的次数，中间的结果集也会比较大。允许算子更容易地使用向量指令集去批处理数据。</p><h2 id="processing-direction">2. Processing Direction</h2><p>根据函数调用的方向，有两种执行方法：</p><h4 id="approach1-top-to-bottom">Approach#1: Top-to-Bottom</h4><p>从根节点开始，往下拉取数据，tuple总是通过函数调用传递。</p><h4 id="approach2-bottom-to-top">Approach#2: Bottom-to-Top</h4><p>从叶子节点开始，向上调用父节点，允许对操作符管道中的缓存/寄存器进行更严格的控制。</p><h2 id="access-methods">3. Access Methods</h2><p>访问方法是DBMS访问存储在表中的数据的方式，即用什么方式存取表中的数据。通常有两种访问模型的方法：数据要么从表中读取，要么通过顺序扫描从索引中读取。</p><h4 id="approach1-sequential-scan">Approach#1: Sequential Scan</h4><p>顺序扫描，全表扫描，一页一页扫描页中的所有数据。顺序扫描操作符遍历表中的每个页，并从缓冲池中检索它。当扫描遍历每个页面上的所有tuple时，它计算谓词，以决定是否将tuple发送给下一个操作符。</p><figure><img src="image-20220302170709275.png" alt="Sequential Scan" /><figcaption aria-hidden="true">Sequential Scan</figcaption></figure><p>对于table中改的每个页，先去缓存中找，如果没有就去硬盘中找。遍历每一个行记录并去处理它。</p><p>DBMS需要维护一个内部游标/指针，以便追溯上次执行到的page或slot的位置。</p><p><strong>优化</strong>:如果在执行计划中存在全表遍历的情况，那么这肯定是一个可以化的地方，下面几种方法可以优化全表扫描速度。</p><ul><li><p><strong>Prefetching</strong>：提前抓取几个页面，这样DBMS在访问每个页面时就不必在存储I/O上阻塞</p></li><li><p><strong>Buffer PoolBypass</strong>：扫描操作符将从磁盘获取的页面存储在本地内存中，而不是存储在缓冲池中，以避免顺序泛洪</p></li><li><p><strong>Parallelization</strong>：使用多个线程/进程并行执行扫描</p></li><li><p><strong>Zone Map</strong>：zone map给每个页做了统计信息</p><figure><img src="image-20220302171253958.png" alt="zone map" /><figcaption aria-hidden="true">zone map</figcaption></figure><p>问题：关于页的信息存在哪里？数据变化的开销没有统计信息大怎么办？</p></li><li></li><li><p><strong>LateMaterialization</strong>：最后一步将数据进行物化，避免大量扫描，比较适合列存储</p><figure><img src="image-20220302171639632.png" alt="late materialization" /><figcaption aria-hidden="true">late materialization</figcaption></figure></li><li><p><strong>HeapClustering</strong>：tuple使用集群索引指定的顺序存储在堆页中</p></li></ul><h4 id="approach2-index-scan">Approach#2: Index Scan</h4><p>当查询需要时，DBMS通过索引去查找数据，在选择过程中涉及到很多因素，包括:：</p><ul><li><p>索引中是否包含输出列</p></li><li><p>索引的值的范围</p></li><li><p>谓词的组成</p></li><li><p>索引是唯一索引还是非唯一索引</p></li></ul><p>对于下面这条SQL，有两个索引<code>index1：age，index2：dept</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students<br>  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">30</span><br>   <span class="hljs-keyword">AND</span> dept <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;CS&#x27;</span><br>   <span class="hljs-keyword">AND</span> country <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;US&#x27;</span><br></code></pre></td></tr></table></figure><p>SQL中含有三个谓词，两个索引。如果走索引去遍历student表，应该使用哪个索引呢？</p><p>什么时候走index1合适？走完索引之后剩下的数据越少。如果所有的学生都30多岁，就4个20多岁。</p><p>什么时候走index2合适？全学校所有的人都小于30岁，只有一小部分人是CS专业的。</p><figure><img src="image-20220302211604658.png" alt="scenario 1&amp;2" /><figcaption aria-hidden="true">scenario 1&amp;2</figcaption></figure><p>考虑一个具有100个tuple两个索引(age和department)的表。在第一个场景中，最好在扫描中使用department索引，因为它只有两个tuple要匹配。选择age索引并不比简单的顺序扫描好多少。在第二种情况下，age索引将消除更多不必要的扫描，是最佳选择。</p><h4 id="approach3-multi-index-bitmap-scan">Approach#3: Multi-Index/Bitmap Scan</h4><p>更高级的DBMS支持多索引扫描，DBMS可以使用位图、哈希表或Bloom过滤器通过集合交集来计算记录id。</p><p>如果有多个索引，DBMS可以用于查询：</p><ul><li>使用每个匹配的索引计算记录id集</li><li>根据查询的谓词组合这些集合(union vs. intersect)</li><li>检索记录并应用所有剩余谓词。</li></ul><p>多索引筛选，还是以上文的SQL为例：先用age索引把小于30岁的人筛选出来，再使用关于dept的索引把CS专业的人筛选出来，最后取他们的交集，最后检查数据中country是US的student。使用韦恩图表示为：</p><figure><img src="image-20220302212003306.png" alt="Multi-Index" /><figcaption aria-hidden="true">Multi-Index</figcaption></figure><h2 id="modification-qureies">4. Modification Qureies</h2><p>对数据库有更改的查询（insert，update，delete）与上面所研究的对表的查询，二者的执行逻辑是完全不同的。修改数据时需要检查约束（要求unique等）；如果这列有索引，也要根据新增数据修改索引。</p><p>update/delete：子算子向目标数据传递recordID，然后去删除。类似于晚物化的思想。算子必须记住本次执行时修改过哪条数据，</p><p>insert：在算子内部物化数据，把整个行记录插入；或需要子算子把行记录物化好，将整个数据传递过来，插入即可。</p><p><strong>Halloween problems</strong></p><p>一种异常现象，更新操作改变了元组的物理位置，导致扫描操作符多次访问元组。这可能发生在集群表或索引扫描上</p><h4 id="update-query-problem">update query problem</h4><p><img src="image-20220302212706236.png" /></p><p><img src="image-20220302212815174.png" /></p><p>上面这个例子会出现重复执行的问题。</p><p>为什么叫Halloweenproblem？这种现象最初是由IBM的研究人员在1976年万圣节那天构建SystemR时发现的。</p><h2 id="expression-evaluation">5. Expression evaluation</h2><p>DBMS将WHERE子句表示为一个表达式树(参见图6中的示例)。树中的节点表示不同的表达式类型。</p><p><img src="image-20220302214204517.png" /></p><p>一些可以存储在树节点中的表达式类型的例子：</p><ul><li>Comparisons (=, &lt;, &gt;, !=)</li><li>Conjunction (AND), Disjunction (OR)</li><li>Arithmetic Operators (+, -, *, /, %)</li><li>Constant and Parameter Values</li><li>Tuple Attribute References</li></ul><p>例：</p><p><img src="image-20220302214307195.png" /></p><p>该SQL可能是一个存储过程，也有可能是一个预编译好了的SQL。</p><p><img src="image-20220302214419660.png" /></p><p><img src="image-20220302214500136.png" /></p><p>效率问题：</p><p><img src="image-20220302214608182.png" /></p><p><img src="image-20220302214648095.png" /></p><p><img src="image-20220302214741734.png" /></p><blockquote><p>为了在运行时计算表达式树，DBMS维护一个上下文句柄，该句柄包含执行的元数据，如当前元组、参数和表模式。然后DBMS遍历树来计算它的操作符并产生一个结果。以这种方式计算谓词很慢，因为DBMS必须遍历整个树，并确定每个操作符要采取的正确操作。更好的方法是直接对表达式求值。</p></blockquote><h1 id="query-execution-ii"><strong>Query Execution II</strong></h1><p>之前关于查询执行的讨论假设查询是用一个worker(即线程)执行的。在现实中，查询通常是与多个worker并行执行的。并行执行为DBMS提供了许多好处：</p><ul><li>吞吐量(每秒查询次数增加)和延迟(每次查询时间减少)方面的性能提高</li><li>从DBMS的外部客户的角度提高响应性和可用性</li><li>潜在地降低总拥有成本(TCO)。这一成本包括硬件采购和软件许可，以及部署DBMS的人工开销和运行机器所需的能源</li></ul><p>DBMS支持两种类型的并行：<strong>查询间并行</strong>和<strong>查询内并行</strong></p><h2 id="并行数据库-vs-分布式数据库">1. 并行数据库 vs 分布式数据库</h2><p>在并行和分布式系统中，数据库分布在多个“资源”上，以提高并行性。这些资源可以是计算资源(例如，CPU内核、CPU插槽、gpu、额外的机器)，也可以是存储资源(例如，磁盘、内存)。区分并行系统和分布式系统是很重要的：</p><ul><li>并行DBMS：在并行DBMS中，资源或节点在物理上是彼此接近的。这些节点采用高速互连方式进行通信。它假设资源之间的通信不仅快速，而且廉价和可靠。</li><li>分布式DBMS：在分布式DBMS中，资源可能彼此相隔很远；这可能意味着数据库跨越世界不同地区的机架或数据中心。因此，资源在公共网络上使用较慢的互连进行通信。节点之间的通信成本更高，故障不能忽略。</li></ul><p>即使一个数据库可能在物理上被划分为多个资源，它对应用程序来说仍然是一个单一的逻辑数据库实例。因此，对单节点DBMS执行的SQL查询应该在并行或分布式DBMS上生成相同的结果。</p><h2 id="process-models">2. Process Models</h2><p>DBMS过程模型定义了系统如何支持来自多用户应用程序/环境的并发请求。DBMS由更多的工人组成，这些工人代表客户执行任务并返回结果。一个应用程序可以在同一时间发送一个或多个请求，这些请求必须被划分到不同的worker。一个DBMS可以采用三种不同的进程模型：</p><h4 id="process-per-worker">Process per Worker</h4><p>第一个也是最基本的方法是每个工人的流程。这里，每个worker都是一个单独的OS进程，因此依赖于OS调度器。应用程序发送请求并打开到数据库系统的连接。一些调度程序接收到请求，并分离出一个worker来处理这个连接。应用程序现在直接与负责执行查询所需请求的worker通信。</p><p>每个工作进程的一个优点是，进程崩溃不会破坏整个系统，因为每个工作进程都在自己的操作系统进程的上下文中运行。这个过程模型提出了一个问题，即在不同的过程中，多个工作人员对同一页面进行大量复制。一个最大化内存使用的解决方案是为全局数据结构使用共享内存，这样它们可以被运行在不同进程中的工作者共享。</p><figure><img src="image-20220316175331395.png" alt="Process per Worker Model" /><figcaption aria-hidden="true">Process per Worker Model</figcaption></figure><p>使用每工作进程模型的系统包括IBM DB2、Postgres和Oracle。</p><h4 id="process-pool">Process Pool</h4><p>进程池模型是每个工作进程模型的扩展。不是为每个连接请求分叉进程，而是将worker保存在一个池中，并在查询到达时由调度程序选择。因为进程共同存在于一个池中，所以进程之间可以共享查询。</p><p>像每个工作进程一样，进程池也依赖于操作系统调度程序和共享内存。这种方法的缺点是较差的CPU缓存局域性，因为不能保证在查询之间使用相同的进程。</p><figure><img src="image-20220316175351745.png" alt="Process Pool Model" /><figcaption aria-hidden="true">Process Pool Model</figcaption></figure><p>使用进程池进程模型的系统包括IBM DB2和Postgres （2015-post）。</p><h4 id="thread-per-worker">Thread per Worker</h4><p>第三种也是最常见的模式是每个工作人员的线程。每个数据库系统只有一个具有多个工作线程的进程，而不是让不同的进程执行不同的任务。DBMS对任务和线程有完全的控制，它可以管理自己的调度。多线程模型可能使用调度程序线程，也可能不使用。</p><figure><img src="image-20220316175536308.png" alt="Thread per Worker Model" /><figcaption aria-hidden="true">Thread per Worker Model</figcaption></figure><p>使用多线程体系结构提供了一定的优势。首先，每次上下文切换的开销更少。此外，共享模型不需要维护。然而，每个工作线程模型并不一定意味着DBMS支持内部查询并行性。</p><h4 id="scheduling">Scheduling</h4><p>总之，对于每个查询计划，DBMS必须决定在哪里、何时和如何执行。相关问题包括：</p><ul><li>它应该使用多少任务?</li><li>应该使用多少CPU内核?</li><li>任务应该在哪个CPU内核上执行?</li><li>一个任务应该在哪里存储它的输出?</li></ul><p>当做出关于查询计划的决定时，DBMS总是比操作系统知道的更多，因此应该按其优先级排序。</p><h2 id="inter-query-parallelism">3. Inter-Query Parallelism</h2><p>在查询间并行中，DBMS并行地执行不同的查询。因为多个worker同时运行请求，整体性能得到了提高。这增加了吞吐量并减少了延迟。</p><p>如果查询是只读的，那么查询之间几乎不需要协调。但是，如果多个查询同时更新数据库，则会出现更复杂的冲突。</p><h2 id="intra-query-parallelism">4. Intra-Query parallelism</h2><p>在查询内并行性中，DBMS并行地执行单个查询的操作。这减少了长时间运行的查询的延迟。内部查询并行性的组织可以按照生产者/消费者范式来考虑。每个操作符都是数据的生产者，同时也是数据的消费者，这些数据来自运行在其下方的某些操作符。</p><p>并行算法存在于每一个关系运算符。DBMS可以使用多个线程访问集中的数据结构，也可以使用分区来划分工作。在内部查询并行性中，有三种类型的并行性:内部操作符、内部操作符和丛式。这些方法并不相互排斥。在给定的工作负载下，以一种优化性能的方式组合这些技术是DBMS的责任。</p><p><strong>Intra-Operator Parallelism (Horizontal)</strong></p><p>在操作符内并行性中，查询计划的操作符被分解成独立的片段，这些片段对不同(不相交的)数据子集执行相同的功能。</p><p>DBMS将一个交换操作符插入到查询计划中，以合并子操作符的结果。交换操作符防止DBMS在计划中执行它上面的操作符，直到它从子节点接收到所有的数据。</p><figure><img src="image-20220316190452118.png"alt="Intra-Operator Parallelism" /><figcaption aria-hidden="true">Intra-Operator Parallelism</figcaption></figure><p>此SELECT的查询计划是对a进行顺序扫描，并将其输入过滤器操作符。为了并行运行，查询计划被划分为不相交的片段。一个给定的计划片段被一个不同的worker操作。exchange操作符对所有片段并发地调用Next，然后这些片段从各自的页面中检索数据。</p><p>一般来说，exchange操作符有三种类型：</p><ul><li><strong>Gather</strong>：将来自多个工作者的结果合并到单个输出流中。这是并行DBMS中最常用的类型</li><li><strong>Repartition</strong>：跨多个输出流重新组织多个输入流。这允许DBMS接受以一种方式划分的输入，然后以另一种方式重新分配它们</li><li><strong>Distribute</strong>：将单个输入流分割为多个输出流</li></ul><p><strong>Inter-Operator Parallelism (Vertical)</strong></p><p>在操作符间并行中，DBMS为了将数据从一个阶段输送到下一个阶段而重叠操作符。这有时被称为流水线并行。参见下图中示例。这种方法在流处理系统中被广泛使用，流处理系统是在输入元组流上连续执行查询的系统。</p><figure><img src="image-20220316190716521.png"alt="Inter-Operator Parallelism" /><figcaption aria-hidden="true">Inter-Operator Parallelism</figcaption></figure><p>在左边的JOIN语句中，一个worker执行JOIN，然后将结果发送给另一个worker，后者执行投影，然后再次发送结果。</p><p><strong>Bushy Parallelism</strong></p><p>Bushy并行是操作符内并行和操作符间并行的一种混合，workers在同一时间执行来自查询计划的不同段的多个操作符。DBMS仍然使用交换操作符来组合这些段的中间结果。</p><figure><img src="image-20220316190821959.png" alt="Bushy Parallelism" /><figcaption aria-hidden="true">Bushy Parallelism</figcaption></figure><p>为了在三个表上执行4-wayJOIN，查询计划被分成4个片段，如下所示。查询计划的不同部分同时运行，其方式类似于操作符间并行。</p><h2 id="io-parallelism">5. I/O Parallelism</h2><p>如果磁盘始终是主要的瓶颈，那么使用额外的进程/线程并行执行查询不会提高性能。因此，能够跨多个存储设备分割数据库非常重要。为了解决这个问题，DBMS使用I/O并行性来跨多个设备分割安装。I/O并行化的两种方法是多磁盘并行化和数据库分区。</p><p><strong>Multi-Disk Parallelism</strong></p><p>在多磁盘并行中，操作系统/硬件被配置为跨多个存储设备存储DBMS的文件。这可以通过存储设备或RAID配置来实现。所有的存储设置对DBMS来说都是透明的，因此worker不能在不同的设备上操作，因为DBMS不知道底层的并行性。</p><p><strong>Database Partitioning</strong></p><p>在数据库分区中，数据库被划分为不相交的子集，这些子集可以分配给离散的磁盘。一些DBMS允许指定每个数据库的磁盘位置。如果DBMS将每个数据库存储在单独的目录中，那么在文件系统级别上就很容易做到这一点。更改的日志文件通常是共享的。</p><p>逻辑分区的思想是将单个逻辑表分割成分离的物理段，这些物理段分别存储/管理。理想情况下，这种分区对应用程序是透明的。也就是说，应用程序应该能够访问逻辑表，而不必关心数据是如何存储的。分区的两种方法是垂直分区和水平分区。</p><p>在垂直分区中，表的属性存储在单独的位置(如列存储)。为了重建原始记录，必须存储元组信息。</p><p>在水平分区中，根据某些分区键将表的元组划分为不相交的段。有不同的方法来决定如何分区(例如，散列、范围或谓词分区)。每种方法的有效性取决于查询。</p><h1 id="query-planning-optimization-i">Query Planning &amp; OptimizationI</h1><p>SQL是声明式的，查询只告诉DBMS要计算什么，而没有告诉DBMS如何计算。因此，DBMS需要将SQL语句转换成可执行的查询计划。但是在查询计划中执行每个操作符有不同的方法(例如，连接算法)，这些计划之间的性能也会有所不同。DBMS优化器的工作是为任何给定的查询选择一个最佳的计划。</p><p>SQL语句的执行效率对数据库的效率影响较大，为了提高查询语句的执行效率，对其进行优化是必不可少的。对查询语句进行优化的技术就是查询优化技术，以确定给定查询的高效执行计划的过程。执行计划是由一系列内部的操作符组成的查询树，其中的操作符按一定的运算关系构成查询的一个执行方案。查询优化就是在数据库优化器引擎生成一个执行策略的过程，尽量使查询的开销（IO,CPU,网络传输等）最小，即生成最好的查询计划。</p><p>优化器的两个流派：启发式和代价式。</p><h4 id="heuristicsrules">1.Heuristics/rules</h4><p>基于规则优化，启发式，也叫RBO。重写SQL来提升执行查询效率，需要去查询catalog（元数据），需要查看数据库表与行列的信息，但是这种该方法不需要知道数据的具体情况。如某列存在索引，只需要使用即可，不需要知道该列的直方图等具体信息。</p><h4 id="cost-based-search">2.Cost-based Search</h4><p>基于代价优化，需要构建代价模型来计算代价的值。需要估计多个等价plan的代价，选择一个最小的代价。需要知道数据的情况，要知道算子需要处理多少数据。</p><p>大部分数据库这两种方法都会采用，如MySQL和PG就同时采用了这两种策略。</p><h4 id="sql执行流程">SQL执行流程</h4><figure><img src="image-20220228164438227.png" alt="Architecture Overview" /><figcaption aria-hidden="true">Architecture Overview</figcaption></figure><p><strong>Application</strong>：用户的业务发送一些query（SQL)，少数数据库会存在一个SQLrewriter，将文本上的数据进行一些预处理，如：字符串级别做一些简单的优化</p><p><strong>Parser</strong>：会把SQL变为一个抽象语法树</p><p><strong>Binder</strong>：连接器，抽象语法树会涉及到库的名称表的名称，元数据的名称；这些名称需要与系统元数据里面的物理id相对应。将用户的表名转成数据库内部的id。</p><p>如果用户请求了一个不存在的表，会报错</p><p><strong>Treerewriter</strong>：大多数数据库拥有，把抽象语法树变为一个标准的执行计划。如：用户写了join，一开始可能join是乱的，rewriter会将所有join变为一个左深树，两两join。将抽象语法树转成一个优化器可以工作的最原始的逻辑计划，过程中也会从查询一些系统元数据</p><p><strong>Optimizer</strong>：随后有一个最原始的逻辑计划输入到optimizer优化器中</p><p><strong>RBO</strong>：如果是启发式的查询，会查询系统元数据进行一些优化</p><p><strong>CVO</strong>：不光会查询系统元数据，还会查询已经定好的数据库代价模型</p><p><strong>PhysicalPlan</strong>：最终生成一个物理计划，每个算子都是实际执行的一个物理算子</p><h4 id="逻辑计划和物理计划">逻辑计划和物理计划</h4><p>逻辑计划：关系代数类型的</p><p>物理计划：如何执行join，具体执行方法（走索引还是走扫描）</p><p>优化器生成逻辑代数表达式到最佳等效物理代数表达式的映射。逻辑计划大致相当于查询中的关系代数表达式。物理操作符使用查询计划中不同操作符的访问路径定义特定的执行策略。物理计划可能取决于所处理数据的物理格式(即排序、压缩)。并不总是存在从逻辑计划到物理计划的一对一映射.</p><p>查询优化分为物理优化和逻辑优化，物理优化主要根据数据读取、表连接方式、表链接顺序、排序等技术随查询进行优化；逻辑计划是指依据关系代数的等价变换做一些逻辑变换。逻辑计划与物理计划中的算子有相对应的关系，比如join算子可能对应嵌套循环等。</p><h2 id="关系代数的等价">1. 关系代数的等价</h2><p>查询优化在很大程度上依赖于一个基本概念，即在等价表达式中保持关系代数的高级属性。如果两个关系表达式等价，那么它们的输出结果集是一样的。数据可以直接在逻辑上判断是不是等价的，有时也叫queryrewriting。</p><p>以下是关系代数等价的几个操作：</p><h4 id="谓词下推">谓词下推</h4><p>关系代数等价的一个例子是谓词下推，其中谓词被应用于序列的不同位置，以避免不必要的工作。</p><p>两个表做join，再将筛选后的结果做输出。可以将谓词下推，在读表的时候在join之前进行筛选，选出分数为A的同学，减少了连表开销，且输出结果是相同的。这两个关系表达式<spanclass="math inline">\(\pi_{name},cid(\sigma_{grade}=&#39;A&#39;(student\Join enrolled)) =\pi_{name},cid(student\Join(\sigma_{grade}=&#39;A&#39;(enrolled)))\)</span>是等价的，这是优化的基本原理。</p><figure><img src="image-20220228164455957.png" alt="Predicate Pushdown" /><figcaption aria-hidden="true">Predicate Pushdown</figcaption></figure><p><img src="image-20220228164715735.png" /></p><h4 id="selection选择">Selection选择</h4><p>尽早地执行过滤，把复杂谓词分解并下推。如：<spanclass="math inline">\(\sigma_{p1\bigwedge p2\bigwedge ...pn}(R) =\sigma_{P1(\sigma_(P2)(...\sigma_{pn}(R)))}\)</span></p><p>简化复杂谓词，例<span class="math inline">\((X=Y {AND}\ Y=3) -&gt;X=3\ AND\ Y=3\)</span></p><h4 id="join连表">Join连表</h4><p>对于inner join来说，既符合交换律<span class="math inline">\(R\Join S= S\Join R\)</span>，又符合结合律<span class="math inline">\((R\Join S)\Join T = R \Join(S\Join T)\)</span>。</p><p>如果多个表进行join，有很多种排列组合。大概有<spanclass="math inline">\(4^{10}\)</span>种可能的执行情况，这也是join成为执行优化比较复杂的原因。</p><h4 id="projection投影">Projection投影</h4><p>提前物化：执行过程中根据输出列筛选中间结果</p><p>晚物化：可能输出的时候再进行回表查找数据</p><p>物化对于列存数据库来说不是特别重要，列存永远都是晚物化的。</p><h2 id="逻辑计划优化">2. 逻辑计划优化</h2><p>我们需要先制定一些规则，有筛选算子select可以向下推，让程序进行匹配，根据规则对逻辑计划进行变换。目标是尽量输出一个高效的逻辑计划，但是不能比较逻辑计划的好坏，内部会根据规则把旧的逻辑计划转换成新的计划。</p><p>一些选择优化包括:</p><ul><li><p>尽可能早地执行过滤器(谓词下推)</p></li><li><p>重新排序谓词，以便DBMS首先应用最具选择性的谓词</p></li><li><p>拆分一个复杂谓词并将其向下推(拆分连接谓词)</p></li></ul><p>一些投影优化包括:</p><ul><li>尽可能早地执行投影，以创建更小的元组并减少中间结果(投影下推)</li><li>项目出所有的属性，除了那些请求或需要的</li></ul><h3 id="计划优化手段">计划优化手段</h3><p>三个表join，如果直接根据SQL生成不加优化的逻辑计划为下图，首先将两个表做笛卡尔积，再将结果与第三个表做笛卡尔积，最后进行筛选。</p><p>当然也可以做一些优化：首先分解为三个谓词（谓词分解）；再将其中两个谓词下推（谓词下推）；将笛卡尔积匹配上谓词变为带有等价连接的join；最后使用投影下推，筛选掉无用的数据。</p><figure><img src="image-20220228165849552.png"alt="split conjunctive predicates" /><figcaption aria-hidden="true">split conjunctive predicates</figcaption></figure><p><img src="image-20220228165903262.png" /></p><figure><img src="image-20220228165916856.png" alt="predicate pushdown" /><figcaption aria-hidden="true">predicate pushdown</figcaption></figure><p><img src="image-20220228165933228.png" /></p><figure><img src="image-20220228170002965.png"alt="replace cartesian products" /><figcaption aria-hidden="true">replace cartesian products</figcaption></figure><h2 id="嵌套子查询">嵌套子查询</h2><p>DBMS还可以在不引用成本模型的情况下优化嵌套的子查询。这类优化有两种不同的方法:</p><ul><li>通过解除关联和/或扁平化来重写查询</li><li>分解嵌套查询并将结果存储到临时表中</li></ul><h3 id="重写">重写</h3><figure><img src="image-20220228170434208.png"alt="Subquery Optimization - Rewriting" /><figcaption aria-hidden="true">Subquery Optimization -Rewriting</figcaption></figure><h3 id="解耦">解耦</h3><p>下图中谓词带有子查询，该查询是一个常数，是一个NestedBlock，需要不断循环执行该查询。可以先执行这个查询，放在嵌套子查询外执行。</p><p>遇到复杂且不便重写询的SQL，可以考虑将子查询作为临时表进行解耦操作。</p><figure><img src="image-20220228170543816.png"alt="Subquery Optimization - Decomposition" /><figcaption aria-hidden="true">Subquery Optimization -Decomposition</figcaption></figure><h3 id="表达式重写">表达式重写</h3><p>DBMS可以使用的另一个优化是删除不可能或不必要的谓词。在这种优化中，DBMS省略了对结果不会改变表中每个元组的谓词的求值。绕过这些谓词可以降低计算成本。</p><p>把表达式进行重写，让谓词本身更高效：使用一些i<code>if-else</code>语句或模式匹配规则进行优化。</p><p>查找符合规则的表达式，如果符合进行重写，直到没有新的规则可供优化。例：</p><p>不可能或不需要的谓词：</p><figure><img src="image-20220308001135635.png" alt="Unnecessary Predicates 1" /><figcaption aria-hidden="true">Unnecessary Predicates 1</figcaption></figure><figure><img src="image-20220308001204145.png" alt="Unnecessary Predicates 2" /><figcaption aria-hidden="true">Unnecessary Predicates 2</figcaption></figure><p>join的消除：查询1中的连接是浪费的，因为A中的每个元组都必须存在于A中。JOIN操作的顺序是查询性能的关键决定因素。对所有可能的联接顺序进行穷举枚举是低效的，因此联接顺序优化需要一个成本模型。然而，我们仍然可以通过启发式的优化方法来消除不必要的连接。</p><figure><img src="image-20220308001222917.png" alt="Join Elimination" /><figcaption aria-hidden="true">Join Elimination</figcaption></figure><figure><img src="image-20220308001237050.png" alt="Unnecessary Predicates 2" /><figcaption aria-hidden="true">Unnecessary Predicates 2</figcaption></figure><p>子查询中的join处理：</p><figure><img src="image-20220308001321955.png" alt="Unnecessary Predicates 2" /><figcaption aria-hidden="true">Unnecessary Predicates 2</figcaption></figure><figure><img src="image-20220308001334787.png" alt="Unnecessary Predicates 2" /><figcaption aria-hidden="true">Unnecessary Predicates 2</figcaption></figure><p>谓词合并：一个类似的优化是合并谓词，查询1中的WHERE谓词有冗余，因为它搜索的是1到150之间的任何值。查询2显示了在查询1中表达请求的更简洁的方法。</p><figure><img src="image-20220308001352699.png" alt="Merging Predicates 1" /><figcaption aria-hidden="true">Merging Predicates 1</figcaption></figure><figure><img src="image-20220308001407955.png" alt="Merging Predicates 2" /><figcaption aria-hidden="true">Merging Predicates 2</figcaption></figure><h1 id="query-planning-optimization-ii">Query Planning &amp;Optimization II</h1><h2 id="代价估算">1. 代价估算</h2><p>DBMS使用costmodel来估计执行计划的成本。这些模型评估查询的等效计划，以帮助DBMS选择最优的一个。代价模型由三部分组成：</p><h4 id="choice-1-physical-cost">Choice #1: Physical Cost</h4><p>物理代价，硬件占比更大。预测CPU周期，IO，cache misses与RAM等。</p><h4 id="choice-2-logical-cost">Choice #2: Logical Cost</h4><p>逻辑代价，估算每个操作符的大小；算子的算法是独立的；需要顾及操作符结果的大小</p><h4 id="choice-3-algorithmic-costs">Choice #3: Algorithmic Costs</h4><p>算法代价，即算子实现的复杂算法。</p><h3 id="statistics">Statistics</h3><p>对查询的所有有效计划的穷举枚举，对于优化器来说太慢了。对于交换和结合的连接，每个n向连接有4n种不同的顺序。优化器必须限制他们的搜索空间，以有效地工作。为了估计查询的成本，DBMS维护关于表、属性和内部目录中的索引的内部统计信息。不同的系统以不同的方式维护这些统计数据。大多数系统都试图通过维护内部统计表来避免实时计算。这些内部表可以在后台更新。</p><p>每个数据库内部都有统计信息，是在catalog中存储一些表，属性以及索引信息。每个数据库更新统计信息的命令是不一样的。对于每一个数据表R，数据库都会维护以下两类信息：</p><ul><li><p><spanclass="math inline">\(N_R\)</span>：表中有多少行数据，R为表名，number oftuples in R。</p></li><li><p><spanclass="math inline">\(V(A,R)\)</span>：R为表名，A是列名，表示A的这列有多少唯一值，numberof distinct values for attribute A。</p></li></ul><p><strong>selection cardinality</strong></p><p>选择基数，<span class="math inline">\(SC(A,R)\)</span> is the averagenumber of records with a value for an attribute A given <spanclass="math inline">\(N_R /V(A,R)\)</span>。选择基数可用于确定将为给定输入选择的元组的数量。唯一键上的相等谓词很容易估计(参见图1)。图2显示了一个更复杂的谓词。如筛选公司中所有男性员工（共有100员工），平均每个值能筛选出来的是50。</p><p>注：这个公式是基于数据不倾斜（均匀）的情况下，假设数据是一致的。这个假设通常是不正确的，但它简化了优化过程，更容易计算代价。</p><h5 id="如何估计基数">如何估计基数？</h5><p><strong>简单谓词</strong>：在某列所有值唯一的情况下，如在主键这一列进行等量选择会比较容易计算基数。</p><p>存在一个people表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> people (<br>  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>  val <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  age <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  status <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">16</span>)<br>);<br></code></pre></td></tr></table></figure><p>此时有一个SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> people<br>  <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p>它的基数是什么呢？不是1就是0。在唯一列进行等价选择会比较容易，但是计算比较<strong>复杂的谓词</strong>会更加麻烦，如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> people<br>  <span class="hljs-keyword">WHERE</span> val <span class="hljs-operator">&gt;</span> <span class="hljs-number">1000</span><br>  <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> people<br>  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">30</span><br>    <span class="hljs-keyword">AND</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Lit&#x27;</span><br>    <span class="hljs-keyword">AND</span> age<span class="hljs-operator">+</span>id <span class="hljs-keyword">IN</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>选择率（selectivity)，这个谓词能够选择出来百分之几的数据，根据谓词的选择率去计算整体的选择率。而且也取决于谓词的类型，如：Equality，Range，Negation，Conjunction，Disjunction。</p><h5 id="selections-complex-predicates">SELECTIONS-complexpredicates</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> people<br>  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>假设<spanclass="math inline">\(V(age,people)\)</span>有五个distinct值（0-4），分布到0至4岁，<spanclass="math inline">\(N_R\)</span> = 5，表中有5个人。</p><p><strong>Equality Predicates</strong> ：选择age=2的人</p><p><span class="math inline">\(A = constant -&gt; sel(A=constant) =SC(P)\ / N_R\)</span></p><p><span class="math inline">\(sel(age=2)=1/5\)</span></p><figure><img src="image-20220228193647161.png" alt="Equality Predicates" /><figcaption aria-hidden="true">Equality Predicates</figcaption></figure><p><strong>Range Predicates</strong> ：选择age&gt;2的人</p><p><span class="math inline">\(sel(A&gt;=a) = (A_{max} -a + 1)\ /\(A_{max} -A_{min} + 1)\)</span></p><p>$sel(age&gt;=2) = (4-2+1) / (4-0+1) = 3/5 $</p><figure><img src="image-20220228194003342.png" alt="Range Predicates" /><figcaption aria-hidden="true">Range Predicates</figcaption></figure><p><strong>Negation Query</strong>：选择age!=2的人</p><p>反查询的选择性是通过从1减去正查询的选择性来计算的。在这个例子中，答案是45，这是准确的.</p><p><span class="math inline">\(sel(not\ P) = 1 - sel(P)\)</span></p><p><span class="math inline">\(sel(age\ !=\ 2) = 1 - (1/5) =4/5\)</span></p><figure><img src="image-20220308113559837.png" alt="Negation Query" /><figcaption aria-hidden="true">Negation Query</figcaption></figure><p>选择率和概率比较相像</p><p><strong>Conjunction</strong>，假设两个谓词是独立的，选择age=2且名字是A开头的人，取这两个数据部分的交集</p><p><span class="math inline">\(sel(P1 \bigwedge P2)= sel(P1) *sel(P2)\)</span></p><p>例：<span class="math inline">\(sel(age=2\ \bigwedge\ name\LIKE\  &#39;A\%&#39;)\)</span></p><p><code>SELECT * FROM people WHERE age=2 AND name LIKE 'A%'</code></p><figure><img src="image-20220228194348899.png" alt="Conjunction" /><figcaption aria-hidden="true">Conjunction</figcaption></figure><p><strong>Disjunction:</strong></p><p>$$sel(P1 v P2) = sel(P1) + sel(p2) - sel(P1  P2) = sel(P1) + sel(p2)- sel(P1) * sel(P2)</p><p>sel(age=2 OR name LIKE 'A%')$$</p><figure><img src="image-20220228194548433.png" alt="Disjunction" /><figcaption aria-hidden="true">Disjunction</figcaption></figure><figure><img src="image-20220228194557407.png" alt="Disjunction1" /><figcaption aria-hidden="true">Disjunction1</figcaption></figure><figure><img src="image-20220228194612646.png" alt="Disjunction2" /><figcaption aria-hidden="true">Disjunction2</figcaption></figure><figure><img src="image-20220308114114487.png" alt="Result Size" /><figcaption aria-hidden="true">Result Size</figcaption></figure><p>假设1：数据是均匀分布的</p><p>假设2：谓词是独立的</p><p>假设3：A表中的每一个数据都能在B表中找到响应匹配 <imgsrc="image-20220308115057644.png" alt="Correlated Attributes" /></p><p>只有本田雅阁，实际上概率</p><p>基于不独立的数据，存在一些方法： <imgsrc="image-20220308115355394.png" alt="Uniform Approximation1" /></p><figure><img src="image-20220308115402679.png" alt="Uniform Approximation2" /><figcaption aria-hidden="true">Uniform Approximation2</figcaption></figure><p>记录全部的统计信息：15keys * 32bits = 60bytes，需要进行一些优化和改进</p><h2 id="直方图">2. 直方图</h2><h4 id="等宽直方图">等宽直方图</h4><p>真实的数据往往是扭曲的，很难做出假设。然而，存储数据集的每一个单独的值是昂贵的。一种减少内存使用量的方法是用直方图存储数据，将值分组。</p><p>把相等宽度的值域作为一个桶，不记录每一个值的基数，记录的是每一个桶的总数。</p><figure><img src="image-20220317161140126.png" alt="Equi-Width Histogram" /><figcaption aria-hidden="true">Equi-Width Histogram</figcaption></figure><p>第一个图显示了整个数据集的原始频率计数。第二个图是等宽直方图，它结合相邻键的计数来减少存储开销。</p><p>缺点：7-9这段信息丢失的可能比较多，可改进为等深直方图</p><h4 id="等深直方图">等深直方图</h4><p>另一种方法是使用等深度直方图，它改变桶的宽度，以便每个桶的总出现次数大致相同。桶的宽度是不定的，但是规定的是个数，为了保证每个桶有大致相同的计数，直方图变化了每个桶的范围。</p><figure><img src="image-20220317161154903.png" alt="Equi-Depth Histogram" /><figcaption aria-hidden="true">Equi-Depth Histogram</figcaption></figure><p>在一定程度上节约内存，缓解了不同的值之间的落差带来的一些落差问题，降低误差。有些系统可能会使用Sketches来生成关于数据集的近似统计，而不是直方图</p><h4 id="sketches">Sketches</h4><p>产生关于数据集的近似统计信息的概率数据结构。cost-model可以用草图代替直方图，提高选择性估计的准确性。</p><p>在概率上帮助我们推断，例子：</p><ul><li>Count-Min Sketch：一个集合中元素的近似频率计数。</li><li>HyperLogLog：估计一个集合中不同元素的数目。Redis中使用HyperLogLog来记录数据的哈希值的第一个一在第几个，最后算出数大概有多少个。</li></ul><h2 id="采样">3. 采样</h2><p>DBMS可以使用抽样将谓词应用到具有类似分布的表的较小副本上，每当底层表的更改量超过某个阈值(例如，元组的10%)时，DBMS就更新案例。</p><p>一个表有10亿行。随机采样出一个小表作为这些数据的代表。例：想要筛选超大表中年龄大于50岁的平均值，可以采样三行，将谓词在小表上先执行，选择性为1/3。那么可以说大表的选择性也是1/3。</p><p>问题：需要采样，同时维护两个表；数据在大表中删掉了小表中也需要维护；SQL中也需要先在小表中执行，资源耗费比较大。</p><figure><img src="image-20220317185059607.png" alt="Sampling" /><figcaption aria-hidden="true">Sampling</figcaption></figure><p>DBMS可以从原始表的一个子集派生谓词的选择性，而不是在表中使用10亿个值来估计选择性。</p><p>通过以上这些方法可以大概地估计谓词的选择性，知道了选择性，也就知道算子送进去了多少数据，输出了多少数据，就能算出每一个算子的开销代价，能够算出整体的执行计划的代价。</p><p>知道代价的目的？在多个候选中选出计划开销最少的执行计划。</p><h2 id="计划列举">4. 计划列举</h2><p>在执行基于规则的重写之后，DBMS将枚举查询的不同计划，并估计它们的成本。然后在耗尽所有计划或某个超时后为查询选择最佳计划。</p><p>不需要计划列举的情况：RBO，如单表操作；多表查询；嵌套查询。只对这三种情况的做法：</p><p>根据启发式的规则去决定，计划应该是什么样的。如选择读表的最佳方案，是使用扫描，二分查找，还是索引？可以写一些简单的规则来规定这几种使用方法。同时也可以进行等价谓词顺序的调整，这种简单的启发式的规则比较适用于简单的OLTP型查询。</p><h4 id="single-relation查询计划">Single-Relation查询计划</h4><p>对于单关系查询计划，最大的障碍是选择最佳的访问方法(例如，顺序扫描、二分搜索、索引扫描等)。大多数新的数据库系统只是使用启发式，而不是复杂的cost模型来选择访问方法。OLTP查询的查询规划很简单，因为它们是可<strong>sargable</strong>(Search ArgumentAble)的。它通常只是选择最好的指数；join几乎总是在基数很小的外键关系上，可以通过简单的启发式实现。<img src="image-20220316125735936.png" alt="Range Predicates" /></p><h4 id="multi-relation查询计划">Multi-Relation查询计划</h4><p>随着join数量的增加，备选方案的数量也迅速增加：需要限制搜索空间。七十年代的SystemR数据库只考虑左深连接树（如下图），左深连接树更适合管道模型，因为DBMS不需要将连接操作符的输出具体化。如果DBMS的优化器只考虑左深树，那么它将减少搜索过程使用的内存数量，并可能减少搜索时间。</p><p>左深树：join的左子树必须是一个join，右子树必须是一个表。这种简单粗暴的方法与最好的工程师写出的计划相差无几。</p><figure><img src="image-20220317195006144.png" alt="System R Optimizer" /><figcaption aria-hidden="true">System R Optimizer</figcaption></figure><p>左深树的好处：如果模型是火山模型的话，可以做到几乎完美的流式操作，中间结果不写入临时文件。</p><p>计划列举要考虑的顺序与方向如下：</p><ol type="1"><li><p>算子的顺序</p></li><li><p>join的算子应该用那种物理实现方案</p></li><li><p>每个表的读表的方式</p></li></ol><p>往往使用动态规划来降低搜索空间： <imgsrc="image-20220316130622197.png" alt="Range Predicates" /></p><p>可以先做R join S，也可以先做T join S；可以使用hashjoin也可以使用merge join。从而算出每步的开销： <imgsrc="image-20220316130838422.png" alt="Range Predicates" /></p><p>接下来可以进剪枝，删掉cost 280和400的路径 <imgsrc="image-20220316130912047.png" alt="Range Predicates" /></p><p>最后 <img src="image-20220316130959726.png"alt="Range Predicates" /></p><p>最后剪枝： <img src="image-20220316131027116.png"alt="Range Predicates" /> 得到两个路径，总开销相加，选出最优解： <imgsrc="image-20220316131054870.png" alt="Range Predicates" /></p><p><strong>候选计划案例</strong></p><p>如何生成搜索算法的计划：</p><ul><li>枚举关系排序： <img src="image-20220316131423939.png"alt="Candidate Plans Example1" /></li></ul><p>有一些简单的规则： <img src="image-20220316131506266.png"alt="Candidate Plans Example2" /></p><p>选择一个顺序，列举join实现的方案： <imgsrc="image-20220316131545061.png" alt="Candidate Plans Example3" /></p><p>针对每一个物理方案，列举每一个表的读表方案 <imgsrc="image-20220316131621862.png" alt="Candidate Plans Example4" /></p><ul><li><p>枚举连接算法选择</p></li><li><p>枚举访问方法的选择</p></li></ul><p>没有真正的dbms是这样做的。这是actuallymore混乱。</p><h4 id="实际应用案例">实际应用案例</h4><ul><li>PG：join树不只有左深树，还有右深树和bushy。</li><li>优化器也有两种：动态规划手段和GEQU遗传算法</li></ul><p>SQL在12个表以内就使用动态规划手段，超过12就使用遗传算法。</p><p>遗传算法：首先第一代随机选取三个可能的算法，把最小的开销记下来，当做最佳的开销算法，同时删掉最差的。然后进行基因图表<img src="image-20220316133130219.png" alt="GEQU1" /></p><p>两个较好方案二代突变，同时随机生成一个方案，代价最小，作为临时最佳方案：<img src="image-20220316133245135.png" alt="GEQU2" /></p><p>第三代： <img src="image-20220316133319674.png" alt="GEQU3" /></p><p>可以一次次往下迭代，达到规定的优化时间后，最终选出cost最小的方案。</p><p>很有可能最后的方案不是最优的，因为规定的优化时间有限，且是突变迭代出来的，也算是比价优秀的方案。</p><p>为什么不使用暴力搜索？表太多了，短时间内找不到最佳的执行方案。</p><h3 id="conclusion">conclusion</h3><figure><img src="image-20220316133609092.png" alt="Range Predicates" /><figcaption aria-hidden="true">Range Predicates</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;query-execution-i&quot;&gt;Query Execution &lt;strong&gt;I&lt;/strong&gt;&lt;/h1&gt;
&lt;figure&gt;
&lt;img src=&quot;image-20220302161405827.png&quot; alt=&quot;Query Plan&quot; /&gt;
&lt;figc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis 多机</title>
    <link href="https://chakkk309.github.io/2022/02/28/redis-duo-ji/"/>
    <id>https://chakkk309.github.io/2022/02/28/redis-duo-ji/</id>
    <published>2022-02-28T05:36:24.000Z</published>
    <updated>2022-02-28T05:42:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复制replicate">复制（Replicate）</h2><h4 id="为什么需要主从复制"><strong>为什么需要主从复制？</strong></h4><ul><li>解决单点故障</li><li>读写分离</li></ul><h4 id="复制过程">复制过程</h4><p>Redis2.8版本以前复制过程分为<strong>同步</strong>和<strong>命令传播</strong>两部分</p><figure><imgsrc="http://r6j1m70cd.hb-bkt.clouddn.com/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%20.jpg"alt="主从复制" /><figcaption aria-hidden="true">主从复制</figcaption></figure><h5 id="同步">1.同步</h5><p>客户端向127.0.0.112345这台Redis服务器发送<code>SLAVEOF 127.0.0.1 6379</code>命令，要求该服务器复制127.0.0.16379这台服务器。即12345对6379进行复制，12345被叫做从服务器（slave），6379则为主服务器（master）。</p><p>同步操作具体过程如下：</p><ol type="1"><li>slave 向 master 发送SYNC命令</li><li>master收到后执行 BGSAVE命令，后台生成一个RDB文件，且使用一个缓冲区来记录从现在开始执行的所有写命令</li><li>master将RDB文件发送给slave</li><li>slave接收并载入RDB文件，将自己的数据库状态更新成为与master一致的状态</li><li>master将其在缓冲区内记录的命令发送给slave</li><li>slave根据这些命令进行更新</li></ol><h5 id="命令传播">2.命令传播</h5><p>同步后主从数据库并不是一直保持一致的状态，这时就需要命令传播来保证主从数据的一致性。一旦master接收到某条写入命令，会向slave发送该条命令，保证两者之间数据的一致性。</p><h5id="版本后slave对于master的复制可分为两种情况">2.8版本后slave对于master的复制可分为两种情况</h5><ul><li><strong>初次复制</strong>：slave之前从没复制过任何master，或这次的master与上次复制的不是同一个</li><li><strong>断线后重复制</strong>：处于命令传播状态下的slave与master断开连接后，重新连接以继续复制master。但是断线重连后的复制效率却很低，需要再一次进行同步与命令传播操作。实际上同步操作不是必须进行的，真正需要的是主从服务器连接中断期间，master新执行的几条写入数据。</li></ul><p>SYNC耗费资源的原因：</p><ul><li>master执行BGSAVE命令：生成RDB文件会耗费master大量CPU内存和磁盘IO</li><li>RDB文件传输：耗费大量网络资源（带宽+流量）</li><li>slave接收RDB文件：载入期间，slave时阻塞状态，无法处理命令请求</li></ul><p><strong>Redis2.8后的复制改进</strong>：2.8后，使用了<strong>PSYNC</strong>命令代替<strong>SYNC</strong>来执行复制时的同步操作，解决断线重复复制时的低效问题</p><p><strong>PSYNC有两种模式：</strong></p><ul><li><strong>完整重同步</strong>：用于处理初次复制情况</li><li><strong>部分重同步</strong>：用于处理断线后重复制情况，master只向slave发送断开连接错过的命令</li></ul><p><strong>部分重同步过程</strong></p><ul><li><p>服务器首次进行复制，向master发送<code>psync ? -1</code>命令，主动请求master进行完整重同步</p></li><li><p>服务器不是首次复制，向master发送<code>PSYNC &lt;runid&gt; &lt;offset&gt;</code>，runid：上次复制的master的运行ID；offset：从服务器当前的复制偏移量</p></li><li><p>master接收到命令后的返回结果：</p><ul><li><code>+FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code>，master将与slave执行完整重同步操作，slave会保存runID在下一次发送时，slave也会将offset作为自己的初始化偏移量</li><li><code>+CONTINUE</code>，将进行部分重同步操作，slave只需等待master发送缺少的部分数据即可</li><li><code>ERROR</code>，表示master的版本低于2.8，两者不兼容，slave将换成master可以识别的PYSNC命令重新发送，最后执行完整重同步操作</li></ul></li></ul><p>图例：复制 -&gt; 网络中断 -&gt; 重复制</p><figure><imgsrc="http://r6j1m70cd.hb-bkt.clouddn.com/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%20PSYNC.jpg"alt="主从复制 PSYNC" /><figcaption aria-hidden="true">主从复制 PSYNC</figcaption></figure><p><strong>三个重要参数</strong></p><p><strong>master和slave的复制偏移量（replication offset）</strong></p><p>执行复制的双方分别维护一个复制偏移量，以判断主从的状态是否一致。master每次向从服务器发送N个字节后，就将自己的复制偏移量加N；slave同理，每接收一个字节的数据就把自己维护的offset+1。</p><p><strong>master的复制积压缓冲区（replication backlog)</strong></p><p>复制积压缓冲区是由master维护的一个固定长度的队列，默认大小为1MB。当master进行命令传播时，同时也会将写命令放入这个缓冲区中存储，并且为队列中的每个字节记录复制偏移量。当slave重新连接上master时，master会根据双方的offset来决定对slave进行何种操作：</p><ul><li><p>offset+1之后的数据存在于缓冲区，master将进部分重同步操作</p></li><li><p>offset+1之后的数据不存在于缓冲区，master将对slave进行完整重同步操作</p></li></ul><p><strong>服务器的运行ID（runID)</strong></p><p>每个redis服务器都会有自己的运行ID，在服务器启动时自动生成。运行ID相当于一个身份标识，用于识别是否是同一个服务器。运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成。</p><h4 id="复制的具体实现">复制的具体实现</h4><p>client向slave发送SLAVEOF命令，复制启动</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SLAVEOF</span> <span class="hljs-number">127.0.0.1</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><h5 id="设置master的地址和端口">1.设置master的地址和端口</h5><p>slave将client给定的naster的IP和端口保存后，回复OK命令，表示复制指令已经被接收</p><h5 id="建立套接字连接">2.建立套接字连接</h5><p>slave根据命令设置的IP和端口，创建向master的socket连接</p><h5 id="发送ping命令">3.发送PING命令</h5><p>slave向master发送PING命令，有以下两个作用：</p><ul><li>检查套接字的读写状态是否正常</li><li>检查master是否能正常处理命令请求</li></ul><p>master的回复有以下三种情况：</p><ul><li>master向slave返回了一个命令回复，但slave未能在规定的timeout内读取命令回复的内容，那么表示主从服务器间的网络连接不佳，此时slave会断开重连</li><li>master向slave返回一个错误，表示master暂时不能处理这个命令请求，这时slave仍然会断开重新请求</li><li>slave收到PONG的回复，表示主从之间网络正常，可以继续复制</li></ul><h5 id="身份验证">4.身份验证</h5><h5 id="发送端口信息">5.发送端口信息</h5><p>slave向master发送自己的监听端口号，master则将其保存</p><h5 id="同步-1">6.同步</h5><p>slave向master发送PSYNC命令，执行同步操作并更新</p><ul><li>完整重同步：slave向master发送<code>PSYNC ? -1</code>命令</li><li>部分重同步：slave向master发送<code>PSYNC &lt;runid&gt; &lt;offset&gt;</code>命令</li></ul><p>master回复有以下三种情况：</p><ul><li><p>master返回<code>+FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code>，master将与slave执行完整重同步操作</p></li><li><p>master返回<code>+CONTINUE</code>，将进行部分重同步操作</p></li><li><p>master返回<code>ERROR</code>，表示master的版本低于2.8，两者不兼容，slave将换成master可以识别的PYSNC命令重新发送</p></li></ul><h5 id="命令传播-1">7.命令传播</h5><p>完成了同步，进入命令传播状阶段，slave只用接收master传过来的写入命令进行同步即可</p><h4 id="心跳检测">心跳检测</h4><p>命令传播阶段，slave会默认以每秒一次的频率，向主服务器发送命令<code>REPLCONF ACK &lt;replication_offset&gt;</code>，作用如下：</p><ul><li><strong>检测主从服务器的网络连接状态</strong>：如果master超过一秒钟没有收到slave发来的ack命令，master则会知道它们之间的连接出现了故障</li><li><strong>辅助实现min-slaves选型</strong>：<code>min-slaves-to-write 3 &amp; min-slaves-max-lag 10</code>将其作为master的配置，即在slave数量少于三个或三个slave的延迟（lag）值都大于或等于10秒时，master将拒绝执行写入命令</li><li><strong>检测命令丢失</strong>：如果因为网络故障，master传播给slave的写命令在半路丢失，那么当slave向master发送ack命令时，master将大仙salve的offset小于自己的，而后master就会在在即的backlog中找到slave缺少的数据，并将其重新发送给slave</li></ul><h4 id="主从复制的缺点">主从复制的缺点</h4><p>只有一个master，宕机后需要人工手动恢复，无法做到高可用</p><h2 id="哨兵sentinel">哨兵（Sentinel）</h2><p>哨兵模式是Redis的高可用性解决方案：通过一个或多个sentinel来监控主服务器及其下属从节点的状态，在master发生故障时，从它的slave中选取一个作为新的master并执行故障转移操作。</p><h4 id="sentinel的初始化">1.Sentinel的初始化</h4><p>当一个哨兵启动时，需要执行以下步骤：</p><ol type="1"><li>初始化服务器</li><li>将普通的Redis服务器使用的代码替换成Sentinel专用代码：二者之间有一些区别，如普通服务器Redis的服务器端口为6379，而Sentinel的端口为26379；且二者的命令表不同。</li><li>初始化Sentinel状态：初始化一个sentinelState结构，保存了服务器中所有和sentinel功能有关的状态。</li><li>根据给定的配置文件，初始化Sentinel的监视主服务器列表</li><li>创建连向主服务器的网络连接：sentinel将成为主服务器的客户端，对于每个被sentinel监视的主服务器来说，sentinel会创建两个连向主服务器的异步网络连接。<ul><li>命令连接：向主服务器发送个命令，并接收命令回复。</li><li>订阅连接：用于订阅主服务器的<code>__sentinel__：</code>hello频道。</li></ul></li></ol><h4 id="sentinel实现原理">2.Sentinel实现原理</h4><p><strong>获取主服务器信息</strong>：sentinel默认以每十秒一次的频率，通过命令连接向主服务器发送INFO命令，通过分析INFO回复来获取主服务器的当前信息，如：当前服务器的运行ID及它的角色（role：master）；以及它手下的slave的基本信息。sentinel会根据这些信息更新主从的实例信息。</p><p><strong>获取从服务器信息</strong>：sentinel发现有主服务器有新的slave时，还会创建到slave的<em>命令连接</em>和<em>订阅连接</em>。<em>命令连接</em>成功创建后，sentinel会向slave发送INFO命令获取其信息并更新slave的实例结构。</p><p>sentinel通过命令连接向其他服务器发送命令，同时通过创建订阅连接来接收消息。对于监视同一个服务器的多个sentinel来说，信息是共享的，这也就意味着多个sentinel可以互相发现。即分析收到的频道信息来感知其他sentinel的存在，发送消息来告知别人自己的存在。sentinel之间会相互创建命令连接，最中监视同一个主从服务器的多个sentinel形成相互连接的网络。</p><h4 id="工作过程">工作过程</h4><p>sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（主从服务器以及其他sentinel）发送<code>PING</code>命令，以此来判断实例是否在线，有两种回复：</p><ul><li>有效回复：<code>+PONG/-LOADING/-MASTERDOWN</code></li><li>无效回复：其他命令或超时未回复</li></ul><p>sentinel的配置文件中<code>down-after-milliseconds</code>字段：如果一个实例在指定的毫秒内连续向sentinel返回无效回复，则会修改该实例的结构，以此表示该实例已经<strong>主观下线</strong>。</p><p>sentinel向其他监视这一服务器的sentinel发送命令，当接收到足够多数量的已下线判断后，就会将master设定为<strong>客观下线</strong>。</p><p>这时候需要从多个sentinel中选举一个领头sentinel（这里使用的是raft选举）来对已经下线的master执行故障转移操作。</p><h5 id="领头sentinel执行故障转移">领头Sentinel执行故障转移</h5><p>1.在已经下线的master的众多slave里选出一个，将其提升为master</p><p>选主规则：正常在线的–&gt; 最近成功通信的 -&gt; 保存的数据较新的 -&gt;优先级最高的 -&gt; 偏移量最大的 -&gt; 运行ID最小的</p><p>2.让所有slave改为复制新的master</p><p>3.将已经下线的旧master设为新master的slave，当其重新上线后会认主</p><blockquote><p>哨兵实现过程：启动并初始化sentinel/获取主服务器信息/获取从服务器信息/向主从服务器发送信息/接收来自主从服务器的频道信息/检测主观下线状态/检测客观下线状态/选举领头sentinel/故障转移</p></blockquote><h2 id="集群cluster">集群（Cluster）</h2><p>Redis集群是一个分布式数据库方案，通过分片（sharding）来进行数据共享，并提供复制和数据转移功能。</p><p>一个集群通常由多个节点组成，为了建立连接，客户端向它们发送<code>CLUSTER MEET</code>命令，通过握手形成了集群。</p><p><strong>节点握手过程：</strong></p><figure><img src="http://r6j1m70cd.hb-bkt.clouddn.com/cluster%20meet.jpg"alt="cluster meet" /><figcaption aria-hidden="true">cluster meet</figcaption></figure><ul><li>节点A会把节点B的相关结构添加到自己维护的字典里</li><li>A向B发送一条MEET消息</li><li>节点B会把节点A的相关结构添加到自己维护的字典里，并返回一条PONG消息</li><li>A向B发送一条PING消息</li><li>握手完成</li></ul><p>随后，节点A会将B的信息通过Gossip协议传播给集群中的其他节点，让其他节点也与B进行握手。最终，B会被集群中所有节点认识，实现最终一致性。</p><p><strong>槽指派</strong></p><p>集群通过分片的方式来保存数据库中的键值对，整个数据库被分为16384个槽（slot），当他们都在被节点进行处理时，集群处于上线状态。</p><ol type="1"><li>一个node节点会将自己负责处理的slots记录起来，还会通过消息发送给集群中其他节点，以此来告知其他节点自己负责处理那些节点，同时也会将收到的其他节点发来的slot信息存储起来。这样下来集群中的每个节点都会知道数据库中的16384个slot分别被指派给了谁。</li></ol><p>clusterNode结构的slots属性和numslot属性记录了节点负责处理那些槽：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clusterNode</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> slots[<span class="hljs-number">16384</span>/<span class="hljs-number">8</span>];<br>    <span class="hljs-type">int</span> numslots;<br>&#125;<br></code></pre></td></tr></table></figure><p>Redis以0为起始索引，16383为终止索引slots是一个二进制数组，一共有2048个字节。如果索引上n的二进制位为1，则代表该节点负责处理槽nnumslots记录节点负责处理的槽的数量</p><p><strong>指派过程</strong>将1-5000的slot指派给节点7000，将5000-10000的slot指派给节点7001，将10000-16383的slot指派给节点7002</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:7000&gt; CLUSTER ADDSLOTS 1 2 3 4 ... 5000<br>127.0.0.1:7001&gt; CLUSTER ADDSLOTS 5001 5002 5003 5004 ... 10000<br>127.0.0.1:7002&gt; CLUSTER ADDSLOTS 10000 10001 10002 10003 ... 16383<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>slot指派完毕，集群进入上线状态。客户端开始向节点发送数据命令。接收到命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己。<ul><li>如果是自己负责，那么该节点直接执行该命令</li><li>如果不是给自己，会向client返回一个MOVED错误，指引clientredirect至正确的节点，并再次发送之前想要之前想要执行的命令。</li></ul></li></ol><p><strong>计算键属于哪个槽</strong></p><p>使用CRC16来进行校验</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">slot_number</span>(<span class="hljs-params">key</span>):<br>    <span class="hljs-keyword">return</span> CRC16(key) &amp; <span class="hljs-number">16383</span><br></code></pre></td></tr></table></figure><p>CRC16(key)用于计算键key的CRC-16校验和，而 &amp;16383则用于计算一个介于0和16383之间的整数作为key的槽号。</p><p><strong>判断槽是否由当前节点负责</strong></p><p>当前节点查找槽信息，如果不是自己负责，返回正确的信息，如：<code>MOVED 6257 127.0.0.1:7001</code>。</p><blockquote><p>客户端通常会与集群中多个节点创建套接字连接，节点转向实际上就是换一个socket来发送命令</p></blockquote><p><strong>重新分片</strong></p><p>重新分片操作可以将任意数量已经指派给某个节点的槽，改为指派给另一个节点，且相应的键值对数据也会进行移动。重新分片操作可以在线进行，也就意味着集群不需要下线就可以完成这一操作。</p><h4 id="复制与故障转移">复制与故障转移</h4><p>Redis集群中的节点分为主节点与从节点。其中master用处理槽，而slave则用于复制某个主节点，并在被复制的主节点下线时，代替该节点继续处理命令请求。</p><p><strong>设置从节点</strong></p><p>向一个节点发送命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">CLUSTER REPLICATE &lt;node_id&gt;<br></code></pre></td></tr></table></figure><p>接收该命令的节点A成为node_id节点的从节点，并对其进行复制，随后节点A在自己的结构中标识自己已经成了从节点，并调用复制代码对node_id节点进行复制。其实可以看出这里的复制操作，和主从复制的功能是一样的，其实底层也是采用了相同的代码。节点A成为了从节点后，会通过消息发送给集群中的其他节点。</p><p><strong>故障检测</strong>集群中每个节点都会定期地向其他节点发送PONG消息，来检测对方是否在线。如果没有在规定的时间内发送PING回复，就会将其标记为<strong>疑似下线</strong>。集群中的各个节点都会通过互相发送消息的方式来交互集群中各个节点的状态信息，当半数以上负责处理槽的主节点都将某个主节点X标记为疑似下线，那么该节点会被认为是<strong>已下线状态</strong>，并广而告之。</p><p><strong>故障转移</strong>当一个从节点发现自己正在复制的主节点进入了已下线模式，开始对该主节点进行故障转移：</p><ul><li>从复制该主节点的众多从节点中选出一个</li><li>被选中的从节点执行SLAVE no one命令，成为新的主节点</li><li>主节点会撤销对所有已下线的主节点的槽指派，并将其全部指派给自己</li><li>新的主节点向集群广播一条PONG消息，通知其他节点，自己已经变成了主节点，并接管了前任的任务</li><li>新的主节点开始工作，故障转移完成</li></ul><p><strong>选举新的主节点</strong>基于Raft的领导选举方法实现，大同小异。</p><h5 id="消息">消息</h5><p>集群中节点通过消息进行通信，有以下五种分类：</p><ul><li><strong>MEET</strong>：握手</li><li><strong>PING</strong>：检测节点是否在线</li><li><strong>PONG</strong>：回复收到MEET或PING消息</li><li><strong>FAIL</strong>：广播某节点已经下线</li><li><strong>PUBLISH</strong>：消息的广播</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;复制replicate&quot;&gt;复制（Replicate）&lt;/h2&gt;
&lt;h4 id=&quot;为什么需要主从复制&quot;&gt;&lt;strong&gt;为什么需要主从复制？&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;解决单点故障&lt;/li&gt;
&lt;li&gt;读写分离&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>博客维护日志</title>
    <link href="https://chakkk309.github.io/2022/01/06/blogmaintain/"/>
    <id>https://chakkk309.github.io/2022/01/06/blogmaintain/</id>
    <published>2022-01-06T15:25:49.000Z</published>
    <updated>2022-08-28T14:33:02.179Z</updated>
    
    <content type="html"><![CDATA[<p><br/></p><h2 id="section">2022/08/28</h2><p>增加了Fluid的主题配置，记录下用到的插件：</p><ul><li>RSS支持：<ahref="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a></li><li>豆瓣书影音界面：<ahref="https://github.com/mythsman/hexo-douban">hexo-douban</a></li><li>加密：<ahref="https://github.com/D0n9X1n/hexo-blog-encrypt">hexo-blog-encrypt</a></li><li>将文章链接从中文转换成拼音：<ahref="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a></li><li>自动对source路径下的图片进行压缩：<ahref="https://github.com/chenzhutian/hexo-all-minifier">hexo-all-minifier</a></li></ul><p>TODO: 希望之后做一下SEO的相关优化</p><h2 id="section-1">2022/04/01</h2><p>github pages绑定自定义域名，并启用https加密</p><p>ref: <ahref="https://github.blog/2018-05-01-github-pages-custom-domains-https/">Customdomains on GitHub Pages gain support for HTTPS</a></p><h2 id="section-2">2022/02/10</h2><p>最近发现了一个比较喜欢的主题Fluid，于是又回归了hexo。于是从：</p><p><img src="image-20220316233124438.png" /></p><p>变为了：</p><p><img src="image-20220316233213881.png" /></p><p>以及今年会更专注于数据库系统的学习记录。</p><h2 id="section-3">2022/01/06</h2><p>使用halo作为博客工具已经有一年多的时间了，驱动力不足，最近才做了一下对于blog的维护工作，大概从以下几个方面着手：</p><h4 id="halo版本升级">Halo版本升级</h4><p>看了一下当前使用的halo还停留在1.4.8，最新的版本已经升级到1.4.16，主要是升级了部分依赖中的log4j2 版本。我是使用docker部署，只需要重新拉取镜像重新运行即可，可参考<ahref="https://docs.halo.run/getting-started/upgrade">官网文档</a>更新。</p><h4 id="设置定时备份">设置定时备份</h4><p>数据备份是一种非常重要的事情，毕竟俺就这么点数字遗产了，<ahref="https://dhjdd.cn/archives/257">参考文章</a>新建定时任务实现自动备份到github。</p><h4 id="关于图床">关于图床</h4><p>之前一直使用七牛云作为图床，但备案很麻烦，所以暂时使用qiniu的测试域名，30天自动过期，这就导致时不时文章中的图片会裂开......目前有以下下几个关于图床的想法：</p><ul><li>自建图床：自建图床固然是最安全的方式，但由于服务器配置不高且文章配图确实很多，综合考虑不太符合当下场景</li><li>继续使用七牛云：使用公有云，性价比比较高。但需要解决域名过期问题（<strong>TODO</strong>）</li><li>使用halo api上传图片：同样使用服务器带宽，不是很推荐</li><li>使用Nginx代理OSS：思路待完善</li></ul><h4 id="更新了about-this-site">更新了【About this site】</h4><h4 id="站点添加https证书todo">站点添加HTTPS证书（TODO）</h4><h2 id="section-4">2021/06/09</h2><p>一次比较惨痛的 #<a href="/2021/06/09/backup/" title="记一次服务器被入侵后的问题分析与数据备份">记一次服务器被入侵后的问题分析与数据备份</a></p><h2 id="section-5">2020/03/22</h2><p>重装系统后的 #<a href="/2020/03/22/retrivehexo/" title="Hexo Installation">Hexo Installation</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;2022/08/28&lt;/h2&gt;
&lt;p&gt;增加了Fluid的主题配置，记录下用到的插件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RSS支持：&lt;a
href=&quot;https://github.com/hexojs/hexo-generato</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Typora + PicGo + Kodo 配置图片自动上传</title>
    <link href="https://chakkk309.github.io/2021/06/24/picconfiguration/"/>
    <id>https://chakkk309.github.io/2021/06/24/picconfiguration/</id>
    <published>2021-06-24T01:09:00.000Z</published>
    <updated>2022-08-25T18:38:16.544Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://typora.io/">Typora</a></strong>：一款简洁高效的Markdown编辑器，最大的特点是 What You See Is What YouMean，所见即所得，让用户更关注写作本身。而写作时避免不了配图，一般图片默认保存在本地的同名+./assest的文件夹中。将文章从本地转移时，往往需要将保存图片的文件夹一同转移，否则他人无法预览图片。</p><p><strong>设置图床</strong>：图床一般是指储存图片的服务器，可以通过特定的url访问，不必访问本地的资源即可查看图片。常用图床有腾讯云COS/Github图床/七牛图床/阿里云OSS/又拍云等，本文以七牛云图床与PicGo工具为例，设置Typora上传图片到该图床。</p><p><strong><ahref="https://portal.qiniu.com/home">七牛云Kodo</a></strong>：七牛对象存储将数据文件以资源的形式上传到空间中，也就是将复制到Typora里面的图片上传到存储空间中。具体操作详见<ahref="https://developer.qiniu.com/kodo/1233/console-quickstart">步骤一</a>。* 创建空间(Bucket)</p><ul><li><p>新建存储空间，成功后如下图所示</p><p><img src="image-20210624145018520.png" /></p></li><li><p>设置外链域名（七牛云可免费提供30天）或绑定自定义CDN加速域名。注：没有外链域名时，无法预览下载或复制外链。</p></li></ul><p><strong><ahref="https://github.com/Molunerfinn/PicGo">PicGo</a></strong> :一个用于快速上传图片并获取图片 URL链接的工具。下载后需设置所用图床信息。 * 选择相应的图床 <imgsrc="image-20210624145744375.png" /> * 填写相应设置 <imgsrc="image-20210624154304688.png" /><br />* AccessKey与SecretKey在创建账号时就已经存在，对应填写即可 *存储空间名称 * 访问网址：外链域名 *存储区域：填写存储空间创建时选择的地域的简称，如下图。 <imgsrc="50533009-e5189100-0b5c-11e9-9812-438576990828.png" /></p><p><strong>设置Typora</strong></p><ul><li>文件下选择偏好设置， 如下图进行设置 <imgsrc="image-20210624150655887.png" /></li><li>点击<code>验证图片上传选项</code>进行测试。 <imgsrc="image-20210624150814217.png" /></li></ul><p><strong>测试</strong></p><ul><li>图片复制到Typora后返回url，可直接通过网络进行访问，至此图床设置完毕。</li></ul><p><strong>测试域名过期问题</strong></p><p>新建一个存储空间后，七牛云提供的免费域名只有30天，超过期限域名失效故存储在七牛与上的资源无法访问，如下图：<img src="image-20210814125443863.png" /> 解决方案：使用七牛云官方工具qshell命令行工具或者可视化界面KudoBroswer进行如下操作：</p><ul><li>绑定已经备案过的自定义域名</li><li>重新创建存储空间，导入已存在的数据</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://typora.io/&quot;&gt;Typora&lt;/a&gt;&lt;/strong&gt;
：一款简洁高效的Markdown编辑器，最大的特点是 What You See Is What You
Mean，所见即所得，让用户更关注写作本身。而写作时避免</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>域名备案与证书申请</title>
    <link href="https://chakkk309.github.io/2021/06/19/domaingenerate/"/>
    <id>https://chakkk309.github.io/2021/06/19/domaingenerate/</id>
    <published>2021-06-19T09:26:00.000Z</published>
    <updated>2022-08-25T18:36:58.410Z</updated>
    
    <content type="html"><![CDATA[<p>1.计划将项目部署在云服务器上并提供域名访问路径，由于项目中需要调取网络摄像头采集图片，网页对摄像头调用的限制比较高，要求必须使用HTTPS协议或者是运行在本地localhost上(127.0.0.1)，否则无法调用。也就是说要将项目上云，要绑定域名并申请SSL证书才能成功被访问。</p><p>2.域名购买完毕，但服务器区域在上海，按相关规定只要网站托管在中国内地（大陆）服务器上，就需要在备案服务器所在的接入商为网站域名申请ICP备案。如果未提交过备案申请就直接将域名解析到服务器上，网站使用HTTP协议访问将被运营商阻断并跳转到固定页面，提示「需要先完成备案操作才能正常访问」，如下图所示：</p><p><img src="image_1624292949327.png" /></p><p>备案流程如下图（来自腾讯云），详见<ahref="https://cloud.tencent.com/document/product/243/39038">如何快速备案网站</a>。<imgsrc="image_1624293258734.png" />可以看到网站备案审核时间较长，若购买短期服务器就更不合适了。然而域名解析至非中国内地服务器无需备案，所以使用境外服务器就方便了很多。</p><p><strong>域名备案注意事项</strong>域名需要在注册有效期内且大于三个月，部分地区管局要求域名有效期大于45天，才能申请备案；且不同的服务器类型也有不同的要求，就阿里云来说，如果是ECS实例需包月3个月以上（含续费）并需要购买公网带宽，才能进行备案操作。（注：按量付费实例无法申请备案服务号）。其他服务器类型详情见<ahref="https://help.aliyun.com/knowledge_detail/36890.html?spm=a2c4g.11186623.6.629.3012718fhroi6L">链接</a>。阿里云备案详细步骤见<ahref="https://help.aliyun.com/document_detail/61819.html?spm=a2c4g.11186623.6.649.426b6204AMB63w">链接</a>，腾讯云见<a href="https://cloud.tencent.com/product/ba">链接</a>，按照提示操作即可。</p><p><strong>域名到期后注意事项</strong>已经备案的域名如果到期后不再续费，<strong>请及时进行备案注销操作</strong>！域名到期后会自动释放供其他用户使用，但域名与备案信息是分开的，需要单独再对网站备案进行注销操作，具体操作需要询问注册相关管局。</p><p><strong>解决方案</strong>1.修改hosts文件，目录为<code>C:\Windows\System32\drivers\etc</code>，该文件包含IP地址到主机名(hostsname)的映射关系，每一条信息都应单列一行，如<code>102.54.94.97 test.com</code>。2.github.io页面跳转，也就是通过访问github域名重定向，也就是页面跳转到到ip+端口访问的方式。3.境外服务器不受限制，可以直接做域名解析与Nginx端口转发，从而通过域名访问网页。编辑Nginx配置文件如下：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑Nginx配置文件</span><br>vim /etc/nginx/nginx.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加端口转发内容</span><br>    server &#123;<br>        listen 80;<br>        server_name http://8.211.129.166;<br> <br>        location / &#123;<br>            proxy_pass http://8.211.129.166:8090;<br>        &#125;<br>    &#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重新加载配置文件</span><br>service nginx reload<br></code></pre></td></tr></table></figure> 登录域名控制台设置域名解析规则，阿里云详见<ahref="https://help.aliyun.com/document_detail/29725.html?spm=a2c1d.8251892.help.dexternal.7e7f5b76LTfkSoL">域名解析规则</a></p><p><strong>申请安全证书</strong> Let'sEnpenty提供免费的证书申请服务，三个月有效期后可进行自动续约操作。</p><p><strong>设置域名解析后不生效</strong>原因：为了提高网站访问速度，系统会自动将已经访问过并获取IP地址的网站存入本机电脑DNS缓存里，一旦再对这个网站进行访问，则不再通过DNS服务器而直接从本机电脑DNS缓存取出该网站的IP地址进行访问。本机电脑DNS缓存出现了问题，导致网站无法访问。通过阿里巴巴DNS查询工具，发现域名解析在本地DNS上与在云解析DNS上的IP地址不同，云解析上是正确的地址，而可以看到本地DNS是仍旧是之前设置过的旧地址，没有被刷新。</p><p><strong>解决方案</strong> ：刷新本地DNS缓存。 *等待TTL时间过后再进行尝试，但本机TTL为1（奇怪啊） *windows刷新DNS命令，在命令行输入：ipconfig /flushdns（无效）这种情况与电脑的网络连接方式有关，如果Windows直接拨号上网可以在 “运行”中输入CMD，然后执行命令ipconfig /flushdns来刷新本机电脑 DNS缓存；如果通过路由上网，需要清空路由的DNS缓存。清空的方法可以通过重启路由解决。如果不能重启路由，需要更换Windows的DNS服务器为其他地址。指定具体DNS服务器，将其设置为阿里云公共DNS地址：223.5.5.5和223.6.6.6或其他公共DNS均可。</p><p><strong>检验解析是否生效</strong> *使用域名检测工具，如在线检测网站或DNS查询工具，如下图阿里DNS查询工具所示，切换DNS服务器后，本地解析已经刷新。<img src="image_1624173649362.png" /> * 使用ping+域名命令进行检测 <imgsrc="image_1624314554832.png" /> * 使用nslookup+域名查看具体信息 <imgsrc="image_1624314702661.png" /></p><p><br></p><blockquote><p>参考：</p><ul><li>https://help.aliyun.com/knowledge_detail/39834.html?spm=a2cle.14465449.0.0.11d423fahqyU1Y#h2--dns-2</li><li>https://www.zhihu.com/search?type=content&amp;q=%E5%88%B7%E6%96%B0%E6%9C%AC%E5%9C%B0DNS%E6%97%A0%E6%95%88</li><li>https://cloud.tencent.com/document/product/302/30597</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.计划将项目部署在云服务器上并提供域名访问路径，由于项目中需要调取网络摄像头采集图片，网页对摄像头调用的限制比较高，要求必须使用HTTPS协议或者是运行在本地localhost上(127.0.0.1)，否则无法调用。也就是说要将项目上云，要绑定域名并申请SSL证书才能成功</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>记一次服务器被入侵后的问题分析与数据备份</title>
    <link href="https://chakkk309.github.io/2021/06/09/backup/"/>
    <id>https://chakkk309.github.io/2021/06/09/backup/</id>
    <published>2021-06-09T14:49:00.000Z</published>
    <updated>2022-08-25T18:35:07.268Z</updated>
    
    <content type="html"><![CDATA[<p>网络安全是一个很大的领域，自己很多时候只是在服务器上单纯地跑跑程序，并没有对恶劣的网络环境有所察觉。虽然被入侵后只要将旧系统删除并且重装后，服务器主机就能够恢复正常。但是为避免本人隔三差五地重装系统与备份，还是很有必要了解一下主机的简易安全防护措施。</p><p>此次被攻击方式是hacker利用系统的程序漏洞主动攻击，如果主机开放了某个网络服务，就必须要启动某个网络软件，由于撰写方式等可能会产生安全问题。当问题被公开，较高水平的cracker会尝试编写攻击代码，因此关闭不需要的网络服务与软件功能是一个良好的习惯，需要警惕网络世界的攻击。</p><p>常见的安全防护措施如下所示：</p><ul><li>通过配置防火墙可以将大部分来自因特网的垃圾链接丢弃，只允许自己开放的服务链接进入本机，它是最基础的安全防护措施。</li><li>网络自动升级软件</li><li>限制连接端口，端口查看的命令netstat与的具体使用如下所示：</li></ul><table><thead><tr class="header"><th>功能</th><th>命令</th></tr></thead><tbody><tr class="odd"><td>列出正在监听的网络服务</td><td>netstat -tunl</td></tr><tr class="even"><td>列出已连接的网络连接状态</td><td>netstat -tun</td></tr><tr class="odd"><td>删除已建立活在监听当中的连接</td><td>netstat -tunp</td></tr></tbody></table><h4 id="修复步骤">修复步骤</h4><p>被攻击后的主机修复工作中最好的方法是重新安装Linux，较为合理的修复步骤如下所示：</p><ol type="1"><li>立即拔出网线，即切断网络流量</li><li>分析日志文件信息，查找可能的入侵途径，如检查主机开放的服务于服务器安全警告等</li><li>将重要数据进行备份，即那些非Linux系统上面原有的数据</li><li>重新安装系统</li><li>对软件漏洞进行修补，关闭不需要的服务</li><li>对数据进行恢复操作，接入网络</li></ol><h4 id="问题分析">问题分析</h4><p>问题出现时间：远程连接Redis数据库出现连接超时情况，随后ssh无法连接。后续尝试解决操作：</p><ol type="1"><li><p>将服务器关机重启</p></li><li><p>登录云控制台对服务器状态进行查看，此时CPU使用率达到100%。</p></li><li><p>修改安全组规则，禁止流量输出，随后可以使用ssh登录。</p></li><li><p>使用top命令查看资源占用状况，根据进程名确认服务器被挖矿，但无法kill掉可疑的进程。由于限制了流量出入，无法判断占用CPU最多的进程。</p></li><li><p>查看<code>/root/.ssh</code>，发现入侵用户与时间，根据登录时间基本确定是原因Redis设置了弱密码未授权登录，漏洞被利用。</p></li><li><p>腾讯云使用VNC登录可以查看当前系统运行的进程，查找最近一天内被修改过的文件<code>find . -type f -ctime -1| xargs ls –a</code>，尝试查找任何后台的守护进程与可疑脚本，未果。</p></li><li><p>尝试启动原有服务，显示内存溢出无法操作，备份重要文件，重装系统。</p></li></ol><h4 id="思考">思考</h4><ol type="1"><li>不要随便关闭防火墙，只开放指定端口供服务访问</li><li>设置安全组规则，严格限制进出操作，尤其是访问数据库的端口只对某一台或几台主机开放</li><li>不要设置无意义或无效的密码</li><li>需要定期数据备份或对服务器打快照</li></ol><h4 id="数据备份">数据备份</h4><p>服务器上的重要数据主要是数据库与文本内容，下面记录对halo博客进行备份的具体操作。</p><ol type="1"><li>将halo文件夹打包，使用SecureCRT工具下载到本地进行备份。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">halo数据默认存放目录为/root/halo/</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打包</span><br>tar -czvf halo.tar .halo/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载到本地</span><br>sz halo.tar<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>重装系统，并将备份好的文件上传到默认路径下并解压缩.</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装上传工具</span><br>yum install lrzsz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上传文件备份</span><br>rz （选择halo.tar）<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压</span><br>tar -zxvf halo.tar<br></code></pre></td></tr></table></figure><p>​ 在Docker上运行程序，安装具体步骤如下： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum update<br>yum -y install docker<br>systemctl start docker<br>systemctl enable docker<br>systemctl status docker<br><span class="hljs-meta prompt_"># </span><span class="language-bash">拉取halo镜像</span><br>docker pull halohub/halo:1.4.8<br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建容器并运行</span><br>docker run -it -d --name halo -p 8090:8090 -v ~/.halo:/root/.halo --restart=always halohub/halo:1.4.8<br></code></pre></td></tr></table></figure></p><h4 id="问题">问题</h4><p>Q1：使用sz命令无法下载文件夹到本地，该工具只能上传或者下载单个或多个文件，无法对文件夹进行操作。A1：答应我打个包好吗！ Q2：使用SecureCRT连接服务器出现如下错误 <imgsrc="image_1624176187521.png" /></p><p>A2：在session option里修改user为当前用户即可。Q3：如果无法进行pull操作，出现错误<code>Get https://registry-1.docker.io/v2/: net/http: request canceled</code>A3：需要重新设置镜像源，步骤如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑daemon.json文件</span><br>vim /etc/docker/daemon.json<br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加新的镜像源：</span><br>&#123;<br>    &quot;registry-mirrors&quot;:[&quot;https://docker.mirrors.ustc.edu.cn&quot;]<br>&#125;<br>systemctl daemon-reload <br>systemctl restart docker<br></code></pre></td></tr></table></figure><p><br></p><blockquote><p>参考：</p><ul><li>https://www.cnblogs.com/yang68h/p/7422372.html</li><li>https://cloud.tencent.com/developer/article/1416030?from=information.detail.bioset%E8%BF%9B%E7%A8%8B</li><li>https://blog.csdn.net/zweiustc/article/details/16338823</li><li>https://www.jianshu.com/p/560111e6d3bf</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网络安全是一个很大的领域，自己很多时候只是在服务器上单纯地跑跑程序，并没有对恶劣的网络环境有所察觉。虽然被入侵后只要将旧系统删除并且重装后，服务器主机就能够恢复正常。但是为避免本人隔三差五地重装系统与备份，还是很有必要了解一下主机的简易安全防护措施。&lt;/p&gt;
&lt;p&gt;此次被攻</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>websocket</title>
    <link href="https://chakkk309.github.io/2021/04/24/websocket/"/>
    <id>https://chakkk309.github.io/2021/04/24/websocket/</id>
    <published>2021-04-24T15:36:00.000Z</published>
    <updated>2022-08-25T18:32:47.253Z</updated>
    
    <content type="html"><![CDATA[<p>项目中需要实现后端向前端发送请求，调取Web端摄像头进行拍照这一功能。但之前接触过的前后端分离项目大多都由前端调用后台接口进行各项操作。查阅各项资料后，发现使用WebSocket可以实现消息的推送。简单摸索了一下，在项目中使用WebSocket的步骤如下（前端使用Angular，后端使用Springboot，Maven管理项目）：</p><p>1.分别编写前端ts和后台java代码，进行WebSocket的创建和连接</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">// 在maven的pom.xml文件添加依赖<br><span class="hljs-comment">&lt;!-- websocket --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>编写后台代码，一共如下三个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// WebSocketConfig配置类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ServerEndpointExporter <span class="hljs-title function_">serverEndpointExporter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerEndpointExporter</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// WebSocketController类，进行WebSocket的各项操作</span><br><span class="hljs-meta">@ServerEndpoint(&quot;/websocket/&#123;username&#125;&quot;)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketController</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DetectMaskService detectMaskService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * log</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(String.valueOf(WebSocketController.class));<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在线连接数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">onlineCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 存放Socket对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, WebSocketController&gt; clients = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;String, WebSocketController&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 建立连接对话</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Session session;<br>    <span class="hljs-keyword">private</span> String username;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 连接成功后调用</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username username</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> session session</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@OnOpen</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onOpen</span><span class="hljs-params">(<span class="hljs-meta">@PathParam(&quot;username&quot;)</span> String username, Session session)</span> &#123;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.session = session;<br>        WebSocketController.onlineCount++;<br>        logger.info(<span class="hljs-string">&quot;增加一连接，当前连接为：&quot;</span> + onlineCount);<br>        clients.put(username, <span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 连接关闭后调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@OnClose</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClose</span><span class="hljs-params">()</span> &#123;<br>        clients.remove(username);<br>        WebSocketController.onlineCount--;<br>        logger.info(<span class="hljs-string">&quot;减少一连接，当前连接为：&quot;</span> + onlineCount);<br>    &#125;<br><br>    <span class="hljs-meta">@OnMessage</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String message)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;receive message &quot;</span> + message);<br>        sendMessage(message);<br>    &#125;<br><br>    <span class="hljs-meta">@OnError</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Error</span><span class="hljs-params">(Session session, Throwable throwable)</span> &#123;<br>        logger.info(<span class="hljs-string">&quot;error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">for</span> (WebSocketController item: clients.values()) &#123;<br>            item.session.getAsyncRemote().sendText(message);<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-comment">// NewsControlller 测试类，新建接口等待被调用</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/news&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewsController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/send&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">send</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        WebSocketController.sendMessage(<span class="hljs-string">&quot;8&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前台代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 前台ts代码如下，在页面初始化方法时调用该下面的函数，页面销毁时进行连接关闭操作即ws.onclose</span><br><span class="hljs-title function_">initWebSocket</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <br>    <span class="hljs-comment">// 创建WebSocket连接 </span><br>    <span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://127.0.0.1:8081/websocket/test&#x27;</span>);<br>    <br>    <span class="hljs-comment">// 开启连接时调用</span><br>    ws.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;connect success&#x27;</span>);<br>    &#125;;<br><br>    <span class="hljs-comment">// 连接出错时调用</span><br>    ws.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;connect open error&#x27;</span>);<br>    &#125;;<br><br>    <span class="hljs-comment">// 连接关闭时调用</span><br>    ws.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;connect closed&#x27;</span>);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">code</span>, event.<span class="hljs-property">reason</span>, event.<span class="hljs-property">wasClean</span>);<br>    &#125;;<br><br>    <span class="hljs-comment">// 接收消息时调用</span><br>    ws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;receive data：&#x27;</span>, evt.<span class="hljs-property">data</span>);<br>      &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.测试：前后端项目启动后，使用postman调用接口，本项目中访问的地址为<strong>http://localhost:8081/news/send</strong>。控制台中输出successmessage，初步连接测试成功。</p><p>3.WebSocket不受浏览器同源策略的限制，没有跨域问题，这也是它于HTTP协议的一大优点，在创建连接时直接访问后台服务启动的端口即可，不必进行端口转发。</p><p>在后台进行逻辑处理时会抛出异常操作，这种情况就会直接造成连接断开，无法进行消息的传递。项目功能要求需要保持连接以便再次发送消息，修改ws.error()以及ws.close()函数，在打印错误信息之后再次初始化操作，进行一个基础的重连操作。大多情况下WebSocket使用心跳机制，定时发送消息进行连接状态的判断。</p><p>此外，Angular中的Rxjs用于订阅消息流的推送十分方便，有相应的WebSocket库可进行连接与调用，直接将大量的重复性的操作放入service中作为Template模板，在使用时进行注入，比原生操作更加方便强大，但封装增强了使用性的同时也牺牲了部分灵活性，在调用某些库或接口时偶有感受。</p><p>Q1：使用<strong>ws.send(data)</strong>时发送了第一次消息后连接就会断开，无法再进行第二次操作。打印错误msg，造成connectclosed的状态码为1009，即CLOSE_TOO_LARGE：由于收到过大的数据帧而断开连接。控制台输出如下：<img src="1009.png" alt="1009" /></p><p>A1：传递消息内容的是base64的图片string格式，数据量比较大导致原有的输出缓冲区容量无法存储，最后error断开了连接。可以通过在config类中自定义增大缓冲区的容量，添加如下代码片段,详见<ahref="https://blog.csdn.net/weixin_43770545/article/details/107109095">link</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> ServletServerContainerFactoryBean <span class="hljs-title function_">createWebSocketContainer</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ServletServerContainerFactoryBean</span> <span class="hljs-variable">container</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletServerContainerFactoryBean</span>();<br>    <span class="hljs-comment">// set output bufferSize</span><br>    container.setMaxTextMessageBufferSize(<span class="hljs-number">512000</span>);<br>    container.setMaxBinaryMessageBufferSize(<span class="hljs-number">512000</span>);<br>    container.setMaxSessionIdleTimeout(<span class="hljs-number">15</span> * <span class="hljs-number">60000L</span>);     <br>    <span class="hljs-keyword">return</span> container;<br>&#125;<br></code></pre></td></tr></table></figure><p>Q2：前台在接收到的消息的<strong>WebSocket.onmessage()</strong>函数中只能进行控制台输出操作，取不到该方法之外的函数，无法通过收到的消息的不同执行相应的操作。补充：该方法已经不认识原始的this是什么了。 与其他语言相反，在JavaScript（Typescript） 中，this的值是根据<strong>方法如何调用</strong> 来定义的。 当通过引用调用该方法时， this的值就变成了所谓的全局对象 ，而最终结果往往不是开发人员设想的那样。解决方法：使用“去this”的JavaScript 来避免这些问题。使用<ahref="https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/function/bind%5D">bind</a>方法来保留这种原始的this。</p><p>A2：猜测或许与函数作用域有关？详见<ahref="https://blog.csdn.net/princek123/article/details/83584208">link</a>，使用这种形式即可进行外部方法的调用。</p><p>Q3：后台接收到消息，无法注入service进行相应的方法调用，项目直接down了，NPE。前端msg状态码1006，CLOSE_ABNORMAL，非正常关闭。<img src="1006.png" alt="1006" /></p><p>A3：WebSocket启动的时候优先于Spring容器，需要在WebSocketServer中将要用到的服务静态初始化。在已创建的WebSocket中进行相应的配置，WebSocket中注入Service的方法见<ahref="https://blog.csdn.net/kxj19980524/article/details/85108047">link</a>，另一种<ahref="https://blog.csdn.net/canot/article/details/52495333">link</a>，还没实践，可以一试。</p><p>Q4： 请求地址有问题：见<ahref="https://blog.csdn.net/weixin_43424101/article/details/85757826">link</a></p><h4 id="websocket协议与http的区别">WebSocket协议与HTTP的区别</h4><p>WebSocket的本质就是为了解决HTTP协议的单向性，HTTP是基于request-respon应答的。一旦服务器主动向客户端发送消息就麻烦了，因为这个时候TCP连接已经释放了，根本无法得知客户端的位置。解决方法很有限，要么就是不断轮询，要么换成长连接（客户端发送请求，服务端等有消息了再回复），但这些都不能从根本上解决问题。而WebSocket，可以进行服务器和客户端的双向通信。尤其是在消息推送方面，灵活方便。</p><p>WebSocket的优点：</p><ul><li>数据格式轻量</li><li>没有同源限制</li><li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL</li></ul><p>Reference：</p><ul><li><ahref="https://blog.csdn.net/cai4561/article/details/106809244">WebSocket断开连接时的状态码及其含义</a></li><li><ahref="https://www.jianshu.com/p/7aed14eb42dd">连接创建基础</a></li><li><a href="https://www.jianshu.com/p/5297732db7f2">重连机制</a></li><li>Mozilla 中<ahref="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">websocketAPI</a> 的使用</li><li><ahref="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications">Writewebsocket Client Application</a></li><li><a href="https://tools.ietf.org/search/rfc6455">WebSocketRFC</a></li></ul><p>ToDo：</p><ul><li>重连与心跳机制</li><li>协议构成</li><li>于Nginx相关内容</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;项目中需要实现后端向前端发送请求，调取Web端摄像头进行拍照这一功能。但之前接触过的前后端分离项目大多都由前端调用后台接口进行各项操作。查阅各项资料后，发现使用WebSocket可以实现消息的推送。简单摸索了一下，在项目中使用WebSocket的步骤如下（前端使用Angul</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Echarts+JQuery</title>
    <link href="https://chakkk309.github.io/2020/08/07/echarts-jquery/"/>
    <id>https://chakkk309.github.io/2020/08/07/echarts-jquery/</id>
    <published>2020-08-07T12:42:33.309Z</published>
    <updated>2021-07-03T05:40:59.609Z</updated>
    
    <content type="html"><![CDATA[<p>ECharts开源来自百度商业前端数据可视化团队，基于html5Canvas，是一个纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表。以官网的一个<ahref="https://echarts.apache.org/examples/zh/editor.html?c=bar-background">条形图</a>为例，记录一下echarts的摸索过程。</p><span id="more"></span><p><strong>jsp文件中引入echarts.js</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.staticfile.org/echarts/4.3.0/echarts.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>添加按钮链接后续被调用的函数</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary btn-sm&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;getBarEchart();&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ace-icon fa fa-plus bigger-110&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>柱状图<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>为图表准备一个Dom用于存储柱状图</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container-bar&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 600px;height:400px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>编写生成柱状图的函数。</strong>其中关于option的配置，从官网查找想选择的图表将其样式复制到项目中即可。<code>data</code>可写静态数据，但大多数时候需要从需要从后台获取动态更新，这里使用的是JQuery的ajax()方法异步加载数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getBarEchart</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 获得对象的引用</span><br>    <span class="hljs-keyword">var</span> dom = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;container-bar&quot;</span>);<br>    <span class="hljs-comment">// 初始化echarts实例</span><br>    <span class="hljs-keyword">var</span> myChart = echarts.<span class="hljs-title function_">init</span>(dom);<br>    <span class="hljs-comment">// 图表配置</span><br>    <span class="hljs-keyword">var</span> option = &#123;<br>        xAxis : &#123;<br>            type : <span class="hljs-string">&#x27;category&#x27;</span>,<br>            <span class="hljs-comment">// data: [&#x27;Mon&#x27;, &#x27;Tue&#x27;, &#x27;Wed&#x27;, &#x27;Thu&#x27;, &#x27;Fri&#x27;, &#x27;Sat&#x27;, &#x27;Sun&#x27;]</span><br>            data : <span class="hljs-title function_">jsonAge</span>()<br>        &#125;,<br>        yAxis : &#123;<br>            type : <span class="hljs-string">&#x27;value&#x27;</span>,<br>            minInterval : <span class="hljs-number">1</span><br>        &#125;,<br>        series : [ &#123;<br>            <span class="hljs-comment">// data: [120, 200, 150, 80, 70, 110, 130],</span><br>            data : <span class="hljs-title function_">jsonCount</span>(),<br>            type : <span class="hljs-string">&#x27;bar&#x27;</span>,<br>            showBackground : <span class="hljs-literal">true</span>,<br>            backgroundStyle : &#123;<br>                color : <span class="hljs-string">&#x27;rgba(220, 220, 220, 0.8)&#x27;</span><br>            &#125;<br>        &#125; ]<br>    &#125;;<br>    <br>    <span class="hljs-keyword">if</span> (option &amp;&amp; <span class="hljs-keyword">typeof</span> option === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>        <span class="hljs-comment">// 使用刚指定的配置项和数据渲染生成</span><br>        myChart.<span class="hljs-title function_">setOption</span>(option, <span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>官网效果：</p><figure><img src="pic.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>ECharts参数有很多，根据所需进行相应的配置即可。记录遇到的小问题：</p><ul><li>饼图的颜色变成灰色</li><li>柱状图图表的横坐标不解析（json没有进行解析）</li><li>纵坐标的最小单位的设置，配置<code>minInterval</code>参数即可</li></ul><p><br/></p><blockquote><p>例：查询某站点用户年龄分布，动态生成柱状图。</p></blockquote><p><strong>页面：ajax请求(Asynchronous JavaScript and XML)</strong></p><p>异步操作：通常指那些发生在幕后的，不会中断进程的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonAge</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">var</span> url = basePath + <span class="hljs-string">&quot;fra-test/Test.jsonAge.html&quot;</span>;<br>    <span class="hljs-keyword">var</span> params = <span class="hljs-literal">null</span>;<br>    $.<span class="hljs-title function_">ajax</span>(&#123;<br>        <span class="hljs-string">&quot;url&quot;</span> : url,<br>        <span class="hljs-string">&quot;data&quot;</span> : params,<br>        <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;post&quot;</span>,<br>        <span class="hljs-string">&quot;async&quot;</span> : <span class="hljs-literal">false</span>,<br>        <span class="hljs-string">&quot;datatype&quot;</span> : <span class="hljs-string">&quot;json&quot;</span>,<br>        <span class="hljs-string">&quot;success&quot;</span> : <span class="hljs-keyword">function</span>(<span class="hljs-params">json</span>) &#123;<br>            <span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;(&quot;</span> + json + <span class="hljs-string">&quot;)&quot;</span>);<br>            result = obj;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>参数一览：</p><table><thead><tr class="header"><th>参数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>url</td><td>规定发送请求的 URL，默认是当前页面</td></tr><tr class="even"><td>data</td><td>规定要发送到服务器的数据</td></tr><tr class="odd"><td>type</td><td>规定请求的类型（GET 或 POST）</td></tr><tr class="even"><td>async</td><td>布尔值，表示请求是否异步处理。默认是 true</td></tr><tr class="odd"><td>dataType</td><td>预期的服务器响应的数据类型</td></tr><tr class="even"><td>success(result,status,xhr)</td><td>当请求成功时运行的函数</td></tr></tbody></table><p><strong>Action：JSON的构建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">jsonAge</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    List&lt;?&gt; list = <span class="hljs-built_in">this</span>.testBiz.getAge();<br>    <span class="hljs-type">JSONArray</span> <span class="hljs-variable">jsonAge</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONArray</span>();<br>    <span class="hljs-keyword">for</span> (Object o : list) &#123;<br>        jsonAge.add(o + <span class="hljs-string">&quot;岁&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">super</span>.genReMessage(jsonAge.toString());<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">jsonCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    List&lt;?&gt; list = <span class="hljs-built_in">this</span>.testBiz.selectAge();<br>    <span class="hljs-type">JSONArray</span> <span class="hljs-variable">jsonCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONArray</span>();<br>    <span class="hljs-keyword">for</span> (Object o : list) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Integer) &#123;<br>            value = (Integer) o;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.testdao.countAge(value);<br>        jsonCount.add(count);<br>    &#125;<br>    <span class="hljs-built_in">super</span>.genReMessage(jsonCount.toString());<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>dao层：sql查询返回list</strong></p><p>无论使用的是什么框架，只有理解了数据的来源和去处、也就是参数传递的流程，才真正能让其为我们所用。</p><p>[补充] <strong>跨站脚本攻击（XSS）</strong></p><p>使用JSON时常见的安全漏洞，通常发生在js从服务器获取到一段JSON字符串并将其转化为js对象时。如果想要对代表对象的文本进行操作，首先要将其转换为对象并且装入内存中。</p><p>例：使用<strong>eval()</strong> 函数来将对象放入内存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> jsonString=<span class="hljs-string">&#x27;&#123;&quot;animals&quot;:&quot;cat&quot;&#125;&#x27;</span>;<br><span class="hljs-keyword">var</span> myObject=<span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;(&quot;</span>+jsonString+<span class="hljs-string">&quot;)&quot;</span>);<br><span class="hljs-title function_">alert</span>(myObject.<span class="hljs-property">animals</span>);<br></code></pre></td></tr></table></figure><p>但是eval（）函数会将传入的字符无差别地编译执行，如果从第三方服务器中获取的JSON数据被替换成为恶意代码，那么我们的站点就会无辜蒙冤在访问者的浏览器中编译执行的代码。<strong>JSON.parse()</strong>便应运而生，该函数仅会解析JSON，不会执行脚本，更加安全可靠。</p><p>例：使用JSON.parse()代替eval（)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> jsonString=<span class="hljs-string">&#x27;&#123;&quot;animals&quot;:&quot;cat&quot;&#125;&#x27;</span>;<br><span class="hljs-keyword">var</span> myObject=<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(jsonString);<br><span class="hljs-title function_">alert</span>(myObject.<span class="hljs-property">animals</span>);<br></code></pre></td></tr></table></figure><p><br/></p><blockquote><p>辅助工具：Google Chrome插件JSONView</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;ECharts开源来自百度商业前端数据可视化团队，基于html5
Canvas，是一个纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表。以官网的一个&lt;a
href=&quot;https://echarts.apache.org/examples/zh/editor.html?c=bar-background&quot;&gt;条形图&lt;/a&gt;
为例，记录一下echarts的摸索过程。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>MyEcplise2015环境配置（JDK+Tomcat）</title>
    <link href="https://chakkk309.github.io/2020/07/29/ecpliseconfigration/"/>
    <id>https://chakkk309.github.io/2020/07/29/ecpliseconfigration/</id>
    <published>2020-07-29T13:15:36.513Z</published>
    <updated>2022-01-07T10:24:28.299Z</updated>
    
    <content type="html"><![CDATA[<h3 id="section"><span id="more"></span></h3><h4 id="配置jdk">配置JDK</h4><p><imgsrc="image-20200729204236089-df800c45fd584fa1b03fd4c304f114e0.png" /></p><p>左侧选择 Java -&gt; installed JRES,添加已有的JDK路径</p><p><imgsrc="image-20200729204328102-11dcf130eb2f42c9bf2c4e06fa8dbee9.png" /></p><p>如图选择</p><p><imgsrc="image-20200729204353314-01554e82c588424984cebd8562fab9f8.png" /></p><p>填写路径和名称（我的当前JDK已经添加完毕）</p><p><img src="image_1624175534961.png" /></p><p>完成后勾选新建好的JDK，OK即可</p><p><imgsrc="image-20200729204506165-a5cd3a66405a43ca83eca1028f212649.png" /></p><h4 id="配置tomcat">配置Tomcat</h4><p>左侧选择 MyEclipse -&gt; Servers -&gt; Runtime Environments</p><p><imgsrc="image-20200729204802753-13d20bb83d6b4926a212996f4cbc51d1.png" /></p><p>选择相应的版本 -&gt; Create a new local server</p><p><img src="image_1624175643582.png" /></p><p>填写名称、路径、以及依赖的JRE</p><p><img src="image_1624175679473.png" /></p><blockquote><p>注：MyEclipse2015不兼容tomcat8.5版本，最新支持到tomcat8.0</p></blockquote><h4 id="导入工程中出现的问题">导入工程中出现的问题</h4><ul><li><p>中文乱码（百度解决）</p></li><li><p>Tomcat启动出错</p></li></ul><p><imgsrc="image-20200729142303490-32d389f1044945a48a1da02c573b4377.png" /></p><p>尝试解决：调大Tomcat的Timeouts/移除Tomcat重新加入/重新导入工程/重启Eclipse</p><p>解决方法：使用的是SSH框架，Hibernate连接数据库的参数没有修改，贴一个<ahref="https://stackoverflow.com/questions/15498724/tomcat-server-not-starting-with-in-45-seconds">解决方法</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;section&quot;&gt;</summary>
    
    
    
    
    <category term="configuration" scheme="https://chakkk309.github.io/tags/configuration/"/>
    
  </entry>
  
  <entry>
    <title>Linux下的软件安装</title>
    <link href="https://chakkk309.github.io/2020/05/11/linuxconfigration/"/>
    <id>https://chakkk309.github.io/2020/05/11/linuxconfigration/</id>
    <published>2020-05-11T10:46:06.000Z</published>
    <updated>2022-08-25T18:10:04.167Z</updated>
    
    <content type="html"><![CDATA[<h3 id="section"><span id="more"></span></h3><h3 id="环境与文件准备">环境与文件准备</h3><ul><li><p>虚拟机软件: VMware 15.5.1</p></li><li><p>镜像文件: <ahref="http://isoredirect.centos.org/centos/7.7.1908/isos/x86_64/">CentOS-7-x86_64-DVD-1908.iso</a></p></li><li><p>终端软件: SecureCRT</p></li><li><p>JDK: 1.8.0_144</p></li><li><p>Tomcat: 8.5.53</p></li><li><p>MySQL: 5.7.29</p></li></ul><h3 id="vmware下安装centos-7.7">VMware下安装CentOS 7.7</h3><ol type="1"><li>安装后启动VMware，点击左上角文件 -&gt; 新建虚拟机</li></ol><p><img src="new.png" /></p><ol start="2" type="1"><li>选择[自定义]</li></ol><p><img src="1.png" /></p><ol start="3" type="1"><li>根据Workstation版本进行选择</li></ol><p><img src="2.png" /></p><p>4.[稍后安装操作系统]</p><p><img src="3.png" /></p><ol start="5" type="1"><li>选择Linux操作系统，版本为CentOS 7 64位</li></ol><p><img src="4.png" /></p><ol start="6" type="1"><li>填写虚拟机名称和路径</li></ol><p><img src="5.png" /></p><ol start="7" type="1"><li>设置处理器数量为2，每个1核</li></ol><p><img src="6.png" /></p><ol start="8" type="1"><li>设置虚拟机内存</li></ol><p><img src="7.png" /></p><ol start="9" type="1"><li>设置网络连接 -&gt; 使用桥接网络</li></ol><p><img src="8.png" /></p><ol start="10" type="1"><li>选择I/O控制器和磁盘类型 ，默认推荐类型即可</li></ol><p><img src="9.png" /></p><p><img src="10.png" /></p><ol start="11" type="1"><li>选择创建新的虚拟磁盘</li></ol><p><img src="11.png" /></p><ol start="12" type="1"><li>选择磁盘容量，这里默认20G</li></ol><p><img src="12.png" /></p><ol start="13" type="1"><li>虚拟机命名</li></ol><p><img src="13.png" /></p><ol start="14" type="1"><li>到此基本参数已经设置完毕</li></ol><p><img src="14.png" /></p><ol start="15" type="1"><li>退出页面，选择编辑虚拟机设置</li></ol><p><img src="15.png" /></p><p><img src="16.png" /></p><ol start="17" type="1"><li>选择CD/DVD选项，右边选择连接 -&gt;使用ISO映像文件（找到之前下载好的文件）</li></ol><p><img src="17.png" /></p><ol start="18" type="1"><li><p>启动安装虚拟机了</p><p>鼠标点进工作区，使用上下键进行控制，选择第一项Install CentOS7，按照提示静待安装</p></li></ol><p><img src="19.png" /></p><ol start="19" type="1"><li>选择语言：简体中文</li></ol><p><img src="21.png" /></p><ol start="20" type="1"><li>首先点进[网络和主机名]，右上角开启网络</li></ol><p><img src="22.png" /></p><ol start="21" type="1"><li>进入[日期&amp;时间]，关闭再重新开启，进行时间同步</li></ol><p><img src="23.png" /></p><ol start="22" type="1"><li>进入[设备选择]，我要配置分区-&gt;选中本地标准磁盘，并添加</li></ol><p><img src="25.png" /></p><ol start="23" type="1"><li>点击左下角加号添加分区</li></ol><p><img src="26.png" /></p><ol start="24" type="1"><li>添加一个挂载点[swap]，期望容量[1024 MB]</li></ol><p><img src="27.png" /></p><ol start="25" type="1"><li>同样添加挂载点[/boot]，容量[1024 MB]</li></ol><p><img src="28.png" /></p><ol start="26" type="1"><li>剩下空间全部分配给[/]</li></ol><p><img src="29.png" /></p><ol start="27" type="1"><li><p>文件系统可以默认，<code>swap-&gt;swap,/root-&gt;xfx</code></p></li><li><p>选择[接受更改]</p></li></ol><p><img src="31.png" /></p><ol start="29" type="1"><li>设置root用户的密码</li></ol><p><img src="32.png" /></p><ol start="30" type="1"><li>设置ROOT好密码之后自动就开始安装了</li></ol><p><img src="33.png" /></p><ol start="31" type="1"><li>安装后输入用户名（root）和密码，成功进入虚拟机</li></ol><p><img src="success.png" /></p><p>​</p><h3 id="使用securecrt连接虚拟机">使用SecureCRT连接虚拟机</h3><ol type="1"><li>点击左边菜单栏session manager-&gt;new session</li></ol><p><img src="s1.png" /></p><ol start="2" type="1"><li>协议默认为SSH2</li></ol><p><img src="s2.png" /></p><ol start="3" type="1"><li>虚拟机上输入<code>ip addr</code> 查看其ip地址，填入hostname中</li></ol><p><img src="s4.png" /></p><p><img src="s3.png" /></p><ol start="4" type="1"><li>虚拟机名称</li></ol><p><img src="s5.png" /></p><ol start="5" type="1"><li>一个新的session建立成功</li></ol><p><img src="s6.png" /></p><ol start="6" type="1"><li>右键 -&gt; 虚拟机名称 -&gt; connect terminal 建立连接</li></ol><p><img src="s7.png" /></p><ol start="7" type="1"><li>选择 Accept&amp;save</li></ol><p><img src="s8.png" /></p><ol start="8" type="1"><li>输入用户名（默认设置的root账号），填写密码</li></ol><p><img src="s9.png" /></p><p><img src="s10.png" /></p><ol start="9" type="1"><li>登录成功</li></ol><p><img src="s11.png" /></p><ol start="10" type="1"><li>设置显示格式</li></ol><p>菜单栏 options -&gt; Session Options</p><p><img src="s12.png" /></p><p>Emulation -&gt; 勾选右侧ANSI color</p><p><img src="s13.png" /></p><p>Appearance -&gt; 设置Character encoding -&gt; UTF-8</p><p><img src="s14.png" /></p><p>此时看到页面颜色已经改变，可以正常进行操作了</p><p><img src="success.png" /></p><h3 id="linux下安装配置jdk">Linux下安装配置JDK</h3><ol type="1"><li><p>首先使用yum安装插件，然后就可以正常使用rz、sz命令上传、下载数据了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install lrzsz<br></code></pre></td></tr></table></figure></li><li><p>选择从桌面上传文件，选择下载好的JDK压缩包 -&gt; Add -&gt; Ok</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rz<br></code></pre></td></tr></table></figure></li></ol><p><img src="rz.png" /></p><ol start="3" type="1"><li><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf jdk-8u144-linux-x64.tar.gz <br></code></pre></td></tr></table></figure></li><li><p>编辑文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /etc/profile<br></code></pre></td></tr></table></figure></li><li><p>尾行插入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">JAVA_HOME=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/jdk1.8.0_144 JRE_HOME=/u</span>sr<span class="hljs-regexp">/local/</span>jdk1.<span class="hljs-number">8.0</span>_144<span class="hljs-regexp">/jre PATH=$PATH:$JAVA_HOME/</span>bin:<span class="hljs-variable">$JRE_HOME</span><span class="hljs-regexp">/bin CLASSPATH=:$JAVA_HOME/</span>lib<span class="hljs-regexp">/dt.jar:$JAVA_HOME/</span>lib<span class="hljs-regexp">/tools.jar:$JRE_HOME/</span>lib export JAVA_HOME JRE_HOME PATH CLASSPATH <br></code></pre></td></tr></table></figure></li><li><p>使文件生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile <br></code></pre></td></tr></table></figure></li><li><p>查看Java版本信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -version<br></code></pre></td></tr></table></figure></li><li><p>JDK配置成功</p><p><img src="java_version.png" /></p></li></ol><p>​</p><h3 id="linux下安装配置apache-tomcat">Linux下安装配置Apache-Tomcat</h3><ol type="1"><li><p>参照上传JDK命令上传并解压Tomcat</p></li><li><p>进入到配置文件下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/apache-tomcat-8.5.53/</span>conf<br></code></pre></td></tr></table></figure></li><li><p>使用vim编辑器进行修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi tomcat-users.xml<br></code></pre></td></tr></table></figure><p>在</tomcat-users>前添加</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;role <span class="hljs-attribute">rolename</span>=<span class="hljs-string">&quot;admin-gui&quot;</span>/&gt;&lt;role <span class="hljs-attribute">rolename</span>=<span class="hljs-string">&quot;manager-gui&quot;</span>/&gt;&lt;role <span class="hljs-attribute">rolename</span>=<span class="hljs-string">&quot;manager-jmx&quot;</span>/&gt;&lt;role <span class="hljs-attribute">rolename</span>=<span class="hljs-string">&quot;manager-script&quot;</span>/&gt;&lt;role <span class="hljs-attribute">rolename</span>=<span class="hljs-string">&quot;manager-status&quot;</span>/&gt;&lt;user <span class="hljs-attribute">username</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attribute">password</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attribute">roles</span>=<span class="hljs-string">&quot;admin-gui,manager-gui,manager-jmx,manager-script,manager-status&quot;</span>/&gt;<br></code></pre></td></tr></table></figure></li><li><p>进入目录，vim编辑，注释掉[<Context></Context>]中的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/apache-tomcat-8.5.53/webapps/manager/META-INF/<br>vi context.xm<br></code></pre></td></tr></table></figure></li><li><p>进入目录，vim编辑，注释掉[<Context></Context>]中的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/apache-tomcat-8.5.53/webapps/host-manager/META-INF<br>vi context.xml<br></code></pre></td></tr></table></figure></li><li><p>进入bin目录进行启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/apache-tomcat-8.5.53/bin/<br>./shutdown.sh<br>./startup.sh<br></code></pre></td></tr></table></figure></li><li><p>浏览器访问<code>http://自己的ip:8080/</code></p></li></ol><p><img src="access_success.png" /></p><p>点击Manager App，输入<code>root/root</code>，显示页面则登录成功</p><p><img src="manager.png" /></p><p><strong>注：需要关闭防火墙并且设置再次开机默认为不启动</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop firewalld.service<br>systemctl disable firewalld.service<br></code></pre></td></tr></table></figure><h3 id="linux下安装配置mysql">Linux下安装配置MySQL</h3><ol type="1"><li><p>首先检查系统是否自带MySQL，没有则上传并且解压安装MySQL</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">rmp <span class="hljs-literal">-qa</span>|grep mysql<br></code></pre></td></tr></table></figure><p>如果解压后的文件名过于繁琐，可以进行重命名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv mysql-5.7.29-el7-x86_64  mysql-5.7.29<br></code></pre></td></tr></table></figure></li><li><p>添加系统MySQL组和MySQL用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupadd mysql<br>useradd -r -g mysql mysql<br></code></pre></td></tr></table></figure></li><li><p>安装数据库：创建data目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd mysql-5.7.29<br>mkdir data<br></code></pre></td></tr></table></figure><p>将<code>/usr/local/mysql-5.7.29</code>的所有者及所属组改为MySQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown -R mysql.mysql /usr/local/mysql-5.7.29<br></code></pre></td></tr></table></figure></li><li><p>在<code>/usr/local/mysql-5.7.295/support-files</code>目录下创建<code>my_default.cnf</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># For advice on how to change settings please see</span><br><span class="hljs-comment"># http://dev.mysql.com/doc/refman/5.7/en/server-configuration-   defaults.html</span><br><span class="hljs-comment"># *** DO NOT EDIT THIS FILE. It&#x27;s a template which will be copied to the</span><br><span class="hljs-comment"># *** default location during install, and will be    replaced if you</span><br><span class="hljs-comment"># *** upgrade to a newer version of MySQL. </span><br><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">sql_mode</span>=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES <br> <br><span class="hljs-attr">basedir</span> = /usr/local/mysql-<span class="hljs-number">5.7</span>.<span class="hljs-number">29</span><br><span class="hljs-attr">datadir</span> = /usr/local/mysql-<span class="hljs-number">5.7</span>.<span class="hljs-number">29</span>/data<br><span class="hljs-attr">port</span> = <span class="hljs-number">3306</span><br><span class="hljs-attr">socket</span> = /tmp/mysql.sock<br><span class="hljs-attr">character-set-server</span>=utf8<br> <br><span class="hljs-attr">log-error</span> = /usr/local/mysql-<span class="hljs-number">5.7</span>.<span class="hljs-number">29</span>/data/mysqld.log<br><span class="hljs-attr">pid-file</span> = /usr/local/mysql-<span class="hljs-number">5.7</span>.<span class="hljs-number">29</span>/data/mysqld.pid<br></code></pre></td></tr></table></figure><p>复制，选择进行覆盖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp support-files/my_default.cnf /etc/my.cnf<br></code></pre></td></tr></table></figure><p><img src="m1.png" /></p></li><li><p>初始化 MySQL，<strong>注意记住初始密码！</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/mysql-5.7.29<br>./bin/mysqld --initialize --user=mysql --   basedir=/usr/local/mysql-5.7.29/ --datadir=/usr/local/mysql-   5.7.29/data/ <br></code></pre></td></tr></table></figure><p><img src="m2.png" /></p></li><li><p>把启动脚本放到开机初始化目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp support-files/mysql.server /etc/init.d/mysql<br></code></pre></td></tr></table></figure></li><li><p>exit后，启动MySQL服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service mysql start<br></code></pre></td></tr></table></figure><p><img src="m3.png" /></p><p>登录MySQL，密码为初始密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/mysql-5.7.29<br>./bin/mysql -u root -p<br></code></pre></td></tr></table></figure><p><img src="m4.png" /></p></li><li><p>修改密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash"><span class="hljs-built_in">set</span> password=password(<span class="hljs-string">&#x27;root&#x27;</span>);</span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">grant all privileges on *.* to root@<span class="hljs-string">&#x27;%&#x27;</span> identified by <span class="hljs-string">&#x27;root&#x27;</span>;</span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">flush privileges;</span><br></code></pre></td></tr></table></figure></li><li><p>添加远程访问权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">use mysql;</span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">update user <span class="hljs-built_in">set</span> host=<span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-built_in">where</span> user = <span class="hljs-string">&#x27;root&#x27;</span>;</span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">flush privileges;</span><br></code></pre></td></tr></table></figure><p>授权root用户时会出现一个错误，可以忽略继续进行</p><p><img src="m5.png" /></p></li><li><p>重启MySQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service mysql restart<br></code></pre></td></tr></table></figure><p><img src="m6.png" /></p></li></ol><p>​ 至此MySQL安装成功</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;section&quot;&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>PowerDesigner逆向工程</title>
    <link href="https://chakkk309.github.io/2020/04/22/powerdesignerreverse/"/>
    <id>https://chakkk309.github.io/2020/04/22/powerdesignerreverse/</id>
    <published>2020-04-22T07:54:31.000Z</published>
    <updated>2022-01-07T10:25:11.838Z</updated>
    
    <content type="html"><![CDATA[<p>使用PowerDesigner逆向工程生成pdm文件</p><span id="more"></span><h2 id="前期准备">前期准备</h2><ul><li>需要转储的数据库文件（.sql），一般为UTF8-无签名格式</li><li>使用Navicat连接MySQL，运行sql文件生成表结构</li><li>安装Visual C++库 <strong>(vc_redist.x86.exe)</strong></li><li>安装ODBC驱动包<strong>(mysql-connector-odbc-8.0.19-win32.msi)</strong></li></ul><h2 id="具体步骤">具体步骤</h2><h3 id="创建模型">创建模型</h3><p>菜单栏选择<code>File-&gt;New Model</code>，填写模型名称和所使用的DBMS</p><p><img src="1.png" /></p><h3 id="配置数据源为导入做准备">配置数据源为导入做准备</h3><p>菜单栏选择<code>Database-&gt;Connect</code>，点击<code>Configure</code>配置数据源</p><p><img src="2.png" /></p><p>在当前连接中新建一个数据源文件，选择数据源类型</p><p><img src="4.png" /></p><p>选择驱动程序<code>Unicode Driver</code></p><p><img src="5.png" /></p><p>选择保存的路径，注意新建文件名称为<code>XXX.dsn</code>，点击下一步-&gt;完成</p><p><img src="6.png" /></p><h3 id="数据库连接并导入数据源">数据库连接并导入数据源</h3><p>连接MySQL，输入主机名、用户名、密码，选择要连接的数据库，填好后点击<code>Test</code>进行连接测试。</p><p><img src="7.png" /></p><p>数据源选择已建好的dsn文件，登录数据库进行连接</p><p><img src="8.png" /></p><h3 id="生成逆向工程">生成逆向工程</h3><p>菜单栏选择<code>Database-Update Model For Database</code>，选择<code>Options</code>设置编码格式为<strong>UTF8</strong></p><p><img src="9.png" /></p><p>返回<code>Selection</code>，查看当前DBMS，选择刚才生成的数据源<code>test.dsn</code>，检查无误后进入下一步</p><p><img src="12.png" /></p><p>默认当前所有数据库中所有表都被选中，首先点击<code>Deselect All</code>取消全选，下拉列表选择需要生成的数据库中的表，右下角<code>Object(s) Selected</code>可查看已选中的表张数，确认后点击ok，开始生成工程。(一定一定要先取消全选，再选择要生成的表，要不然就会.......emmm很辣眼睛）</p><p><img src="10.png" /></p><p>创建成功就可以看到数据模型了</p><p><br/></p><p>注：可以使用快捷键<code>Ctrl+Shift+X</code>执行一些VB脚本用于调整模型表的结构等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用PowerDesigner逆向工程生成pdm文件&lt;/p&gt;</summary>
    
    
    
    
    <category term="configuration" scheme="https://chakkk309.github.io/tags/configuration/"/>
    
  </entry>
  
  <entry>
    <title>Gitbook Configuration</title>
    <link href="https://chakkk309.github.io/2020/04/03/gitbookconfigration/"/>
    <id>https://chakkk309.github.io/2020/04/03/gitbookconfigration/</id>
    <published>2020-04-03T03:20:38.000Z</published>
    <updated>2022-01-07T12:18:30.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于">关于</h2><ul><li>gitbook.com 提供托管，协作功能和易于使用的编辑器，具体操作在<ahref="https://docs.gitbook.com/">docs</a>上有详尽说明</li><li>提供内容导出功能，格式可以是PDF, ePub 或 Mobi</li><li><ahref="https://legacy.gitbook.com">gitbook旧版本</a>已经弃用，访问自动跳转<a href="gitbook.com">gitbook新官网</a></li></ul><span id="more"></span><hr /><p>注：由于Gitbook进行了改版，之前的某些安装命令已不再适用，故在2022/1更新一版安装手册，适用目前的Gitbook版本。</p><h2 id="安装步骤">安装步骤</h2><h3 id="安装node.js">安装Node.js</h3><p><ahref="https://nodejs.org/en/">官网</a>下载，确认版本，v4.0.0及以上可用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">C:\Users\Administrator&gt;node -v<br>v12.16.1<br></code></pre></td></tr></table></figure><p>注：windows用户推荐下载.msi文件，仅点击node.exe是不会安装npm包的（所以在后续使用npm安装时会发现根本没有）</p><h3 id="npm安装gitbook">npm安装Gitbook</h3><p>npm在Node.js下载时也已经安装完毕，直接进行Gitbook安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install gitbook-cli -g<br></code></pre></td></tr></table></figure><p>注：如果出现以下错误，应该降低node版本，卸载重新安装低版本或者使用<ahref="https://github.com/coreybutler/nvm-windows">nvm</a>进行node版本管理（但是需要注意也有很多坑），推荐对node进行多版本管理，因为Gitbook支持的node及相关npm版本是在是有点低......有时使用npminstall时会提示node版本过低需要升级......</p><h3 id="检查版本">检查版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">C:\Users\Administrator&gt;gitbook -V<br>CLI version: 2.3.2<br>GitBook version: 3.2.3<br></code></pre></td></tr></table></figure><h2 id="基本使用">基本使用</h2><p>创建book，相当于创建一个样板书，初始化结构目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">C:\Users\Administrator&gt;gitbook init<br>warn: no summary file in this book<br>info: create README.md<br>info: create SUMMARY.md<br>info: initialization is finished<br></code></pre></td></tr></table></figure><p>如果要将书创建到一个新目录中，可以指定文件路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gitbook init ./directory<br></code></pre></td></tr></table></figure><h2 id="编译预览">编译预览</h2><p>进入新建的gitbook文件夹下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">gitbook serve<br><br>Starting server ...<br>Serving book on http://localhost:4000<br><br></code></pre></td></tr></table></figure><p>等价于在根目录指定文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gitbook serve ./directory<br></code></pre></td></tr></table></figure><p>该命令实际上会先调用<code>gitbook build</code>编译书籍，完成之后打开服务，监听在4000端口上。也可以使用<code>gitbook build</code>命令来生成网页而不开启服务器。</p><p>浏览器搜索<code>http://localhost:4000</code>查看当前效果:</p><figure><img src="serve.png" alt="serve.png" /><figcaption aria-hidden="true">serve.png</figcaption></figure><p>基本的搜索、字体、主题以及分享都已经存在，且页面非常简洁，符合我对于Gitbook的期待:)</p><p>运行serve命令会自动生成一个<code>_book</code>文件夹，里面是一些配置文件 <img src="overall.png" alt="overall.png" /></p><h2 id="配置">配置</h2><p>初始化后生成两个md文件，<code>README.md</code>和<code>SUMMARY.md</code></p><p><code>SUMMARY.md</code>中只有两行：二级标题和一个跳转到README.md的链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Summary</span><br><br>* [Introduction](README.md)<br></code></pre></td></tr></table></figure><p>而README.md中则更为简单，只有标题，其他内容等待填充</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Introduction</span><br></code></pre></td></tr></table></figure><p>目录包括三部分内容：</p><ul><li>SUMMARY.md</li><li>README.md</li><li>book.json</li></ul><p>可以理解为<strong>SUMMARY</strong>是gitbook的骨架结构或章节目录，<strong>README</strong>则是每章填充的内容，<strong>book.json</strong>作为主体配置文件，有各种插件供用户使用。</p><h2 id="常用命令">常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">预览编译</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gitbook serve</span> <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出当前正在使用的gitbook版本</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gitbook current</span> <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出gitbook可用命令</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gitbook <span class="hljs-built_in">help</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装当前项目所需插件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gitbook install</span> <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">默认输出epub 到当前项目（电子书，可能需要ebook-convert插件）</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gitbook pdf</span> <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">默认输出mobi 到当前项目</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gitbook mobi</span> <br></code></pre></td></tr></table></figure><h2 id="部署方式">部署方式</h2><h3 id="github绑定发布">1.github绑定发布</h3><h4 id="新建仓库">新建仓库</h4><p>进入github个人主页，新建一个仓库，可不勾选创建README文件（Gitbook目录已自带）</p><p>进行git操作，根据提示在工作区依次执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs git">git init<br>git add .<br>git commit -m &quot;gitbook test&quot;<br>git remote add origin https://github.com/github用户名/仓库名.git<br>//除了http方式，也可以使用SSH方式添加远程库，二者取一即可<br>git remote add origin git@github.com:用户名/仓库名.git<br>git push -u origin master<br></code></pre></td></tr></table></figure><p>已把本地的Gitbook文件夹成功推送到test仓库中了，再次查看主页，不再是一个空仓库，有上传内容且也可以进行clone等操作。</p><h4 id="关联仓库主页域名">关联仓库主页/域名</h4><p>点击<code>Setting</code>找到<code>GitHub Pages</code>选项，选择下Source，master或者自己再新拉一个分支都可。</p><p>设置完毕，可以通过<code>github.io/仓库名</code>这种方式进行访问。</p><p>如果之前已经将github.io绑定域名，github非常友好地自动将新建的仓库放到相应的二级域名下，提示<strong>Yoursite is published at http://绑定的域名/该仓库名/</strong>，把github默认的仓库主页替换成绑定的域名进行访问就可以看到相应页面了。</p><h4 id="关联hexo页面">关联hexo页面</h4><p>既然绑了二级域名，索性在博客里也显示出来，新建一个页面就好</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new page &quot;gitbook&quot;//新建页面<br></code></pre></td></tr></table></figure><p>首先查看一下站点配置文件中<code>relative_link: false</code>选项是否设置为false，主题的配置文件找到<code>menu</code>，新建一个子目录<code>gitbook:二级域名</code>，重新生成部署即可</p><h3 id="服务器nginx">2.服务器（Nginx）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建gitbook目录</span><br>mkdir -p /usr/local/nginx/gitbook<br>cd /usr/local/nginx/gitbook<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">上传gitbook</span><br>rz（_book.tar.gz）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压</span><br>tar -zxvf _book.tar.gz<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑配置文件</span><br>vi /usr/local/nginx/conf/nginx.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">部分配置如下</span><br> server &#123;<br>        listen       开放的端口号;<br>        server_name  localhost;<br><br>        location / &#123;<br>           # 内容<br>        &#125;<br><br>        location /gitbook/&#123;<br>            alias /usr/local/nginx/gitbook/_book/;<br>            index index.html;<br>        &#125;<br>        <br><span class="hljs-meta prompt_"># </span><span class="language-bash">访问ip:端口号/gitbook/目录即可</span><br></code></pre></td></tr></table></figure><h3 id="gitbook.com社区公开">3.gitbook.com社区公开</h3><hr /><p>对于使用存在疑问，可以先访问<ahref="https://github.com/GitbookIO/gitbook/blob/master/docs/faq.md">FAQ</a>进行问题查找</p><p><br></p><blockquote><p>参考文章：</p><p>https://github.com/GitbookIO/gitbook</p><p>https://www.jianshu.com/p/421cc442f06c</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;关于&quot;&gt;关于&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;gitbook.com 提供托管，协作功能和易于使用的编辑器，具体操作在&lt;a
href=&quot;https://docs.gitbook.com/&quot;&gt;docs&lt;/a&gt;上有详尽说明&lt;/li&gt;
&lt;li&gt;提供内容导出功能，格式可以是PDF, ePub 或 Mobi&lt;/li&gt;
&lt;li&gt;&lt;a
href=&quot;https://legacy.gitbook.com&quot;&gt;gitbook旧版本&lt;/a&gt;已经弃用，访问自动跳转
&lt;a href=&quot;gitbook.com&quot;&gt;gitbook新官网&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>大数据科学与应用课程记录</title>
    <link href="https://chakkk309.github.io/2020/03/28/bigdatarecord/"/>
    <id>https://chakkk309.github.io/2020/03/28/bigdatarecord/</id>
    <published>2020-03-28T13:51:48.000Z</published>
    <updated>2022-08-27T14:04:38.480Z</updated>
    
    <content type="html"><![CDATA[<p>本文用于记录《大数据科学与应用》这门课程的种种…..</p><span id="more"></span><h2 id="一.-环境安装">一. 环境安装</h2><ul><li>Ubuntu16.04 64位（gdm3）</li><li>SSH</li><li>Java（jdk1.8）</li><li>Hadoop 3.1.3 伪分布式模式</li><li>HDFS：hadoop包含其组件</li><li>HBase2.2.3</li><li>Eclipse</li></ul><h2 id="二.-一些问题">二. 一些问题</h2><h3id="启动hadoop时会出现permission-denied-publickeypassword错误">1.启动hadoop时会出现<code>Permission denied (publickey,password)</code>错误</h3><p>原因是安装SSH的时候没有设置<strong>免密登陆</strong></p><p>首先使用<code>ssh localhost</code>登录，如果此时需要输入用户密码才能登入，确实没有设置无密码登录，那么接下来就需要再生成密钥并将其加入到授权中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.ssh/ <br>ssh-keygen -t -rsa <span class="hljs-comment">#生成密钥 </span><br><span class="hljs-built_in">cat</span> ./id_rsa.pub &gt;&gt; ./authorized_keys <span class="hljs-comment">#加入授权</span><br></code></pre></td></tr></table></figure><p>在生成密钥后会询问密钥的存放位置，按Enter公钥会默认存放在<em>/home/hadoop/.ssh/id_rsa.pub</em>路径，接下来需要输入passphrase，直接回车默认不设置密码。设置完成再次登录本机，有可能出现服务器添加完公钥报错的情况：<code>sign_and _send_pubkey:signing failed: agent and refused opeartion</code>，需要进行如下操作:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(ssh-agent -s)</span>&quot;</span><br>ssh -add<br></code></pre></td></tr></table></figure><p>此时再次登录ssh，成功。</p><p>通过<code>./sbin/start-dfs.sh</code>启动hadoop,随后使用<code>jps</code>查看，NameNode、DataNode和 SecondaryNameNode全部启动成功，一切正常。</p><h3 id="关于tmp文件夹自动删除问题">2.关于tmp文件夹自动删除问题</h3><p>之前有把下载的文件放入临时文件夹的情况，第二天再登录时怎么也找不到要解压的文件，显示文件丢失。<img src="miss.png" /></p><p>Ubuntu系统下/tmp目录文件重启后会自动清理，它是用来存放一些临时文件的，重要的文件最好不要放在其中！</p><p>进入<code>/etc/default/rcS</code> 文件中查看： <imgsrc="Src.png" /></p><p>发现有一项<code>TMPTIME=0</code>，0表示重启后删除文件，设置为-1时不会自动删除文件，为正整数时表示文件的保留时间，可以根据自己的需求进行相应的设置。</p><h3 id="如何查看系统版本3种方法">3.如何查看系统版本(3种方法）</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>version<br></code></pre></td></tr></table></figure><p>我的系统显示如下,依次为<em>Linux内核版本号</em>、<em>gcc编译器版本号</em>和<em>Ubuntu版本号</em>。<img src="1.png" /></p><p>查看Linux内核和版本的位数 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">uanme -<span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure> <img src="2.png" /></p><p>还有一种方法比较直观： <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/etc/</span>lsb-release<br></code></pre></td></tr></table></figure> <img src="3.png" /></p><h3 id="hdfs文件的恢复机制待完善">4.hdfs文件的恢复机制（待完善）</h3><p>hdfs的垃圾回收站</p><h3 id="设置linux环境变量的方法">5.设置Linux环境变量的方法</h3><p>设置 Linux 环境变量可以通过 export实现，也可以通过修改几个文件来实现。</p><p><strong>全局环境变量，对所有用户都会生效</strong></p><ul><li><code>etc/profile</code>:系统的每个用户设置环境信息.当用户登录时，该文件被执行一次，并从/etc/profile.d 目录的配置文件中搜集shell的设置。一般用于设置所有用户使用的全局变量。</li><li><code>/etc/bashrc</code> :当 bash shell被打开时，该文件被读取。也就是说，每次新打开一个终端shell，该文件就会被读取。</li></ul><p><strong>只对单个用户生效的对应方法</strong></p><ul><li><p><code>~/.bash_profile 或 ~/.profile</code>:只对单个用户生效，当用户登录时该文件仅执行一次。用户可使用该文件添加自己使用的shell变量信息。另外在不同的LINUX操作系统下，这个文件可能是不同的，如果存在几种的话，那么执行的顺序便是：~/.bash_profile、~/.bash_login、 ~/.profile。</p><p>当前我是用的Ubuntu 系统一般是 ~/.profile 文件。</p></li><li><p><code>~/.bashrc</code>:只对单个用户生效，当登录以及每次打开新的shell 时，该文件被读取。</p></li></ul><p><strong>修改 /etc/environment这个文件也能实现环境变量的设置</strong></p><ul><li>/etc/environment设置的是整个系统的环境，而/etc/profile是设置所有用户的环境。</li><li>/etc/environment 中直接通过 <code>VAR="..."</code> 的方式设置</li><li>使用 <code>source /etc/environment</code>可以使变量设置在当前窗口立即生效，需注销/重启之后，才能对每个新终端窗口都生效。</li></ul><h3 id="hmaster初始化时出错"><strong>6.HMaster初始化时出错</strong></h3><p>HBase安装版本为2.2.3 ，节点已正常启动，但是使用hbase shell命令创建表时出现错误。</p><p><img src="HMaster_error.png" /></p><p>随后查看<code>usr/local/hbase/log</code>中的HMaster日志，发现问题。</p><p><img src="HMaster_log.png" /></p><p>重新启动hbase即可恢复，贴一个<ahref="https://community.cloudera.com/t5/Support-Questions/org-apache-hadoop-hbase-PleaseHoldException-Master-is/m-p/131710">问题答案</a>。</p><h3 id="用户网站行为分析问题">7.【用户网站行为分析】问题</h3><p>跑了一下厦门大学实验室【用户网站行为分析】的这个demo，虽然内容已经描述地很详尽了，但是由于环境问题的不同还是有一些卡住的瞬间......</p><h4id="ubuntu下mysql5.7导入中文乱码问题">1.Ubuntu下Mysql5.7导入中文乱码问题</h4><p>原因是character_set_server默认设置为latin1，需要将其修改为utf8格式。</p><ul><li>首先进入数据库，查看当前编码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql -uroot -proot<br>show variables like &quot;char%&quot;;<br></code></pre></td></tr></table></figure><figure><img src="image-20200601102844651.png" alt="image-20200601102844651" /><figcaption aria-hidden="true">image-20200601102844651</figcaption></figure><p>可以看到当前<code>character_set_server</code>的值为latin1，需要将其修改为utf8编码格式。</p><ul><li><p>方法一：可以在当前终端执行<code>set character_set_server=utf8</code>命令，但是数据库重启后就无效了，不建议使用。</p></li><li><p>方法二：修改<code>my.cnf</code>配置文件</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">另起一个终端</span><br>cat /etc/mysql/my.cnf<br>sudo vi /etc/mysql/my.cnf<br><br>命令模式G快速跳到文末，内容添加如下：<br><br>[client]<br>default-character-set=utf8<br><span class="hljs-meta prompt_">#</span><span class="language-bash">影响系统变量character_set_client和character_set_connectioncharacter_set_results，所以[client]那部分设置不用添加</span><br>[mysqld]<br>character-set-server=utf8<br>collation-server=utf8_general_ci  <br><span class="hljs-meta prompt_">#</span><span class="language-bash">影响系统变量character_set_server和character_set_database，因为这两个系统变量默认是latin1，所以要添加</span><br></code></pre></td></tr></table></figure><ul><li>保存后重启Mysql</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service mysql restart<br></code></pre></td></tr></table></figure><ul><li>重新登录查看编码，character-set-server已变为utf8格式。此时再重新进行表的导入，中文字符显示正常。</li></ul><h4id="hadoop命令执行hbase应用jar包时的环境变量加载问题">2.hadoop命令执行hbase应用jar包时的环境变量加载问题</h4><p>执行<strong>hadoopjar</strong>命令出错，需要设置<strong>HADOOP_CLASSPATH</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/hadoop/etc/hadoop <br>sudo vi hadoop.env.sh<br><br>命令模式G快速跳到文末，内容添加如下：<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Extra Java CLASSPATH elements.  Automatically insert capacity-scheduler.</span><br>if [ -z $HBASE_HOME  ];<br>then<br>   export HADOOP_CLASSPATH=$&#123;HADOOP_CLASSPATH&#125;<br>else<br>   export HADOOP_CLASSPATH=$&#123;HADOOP_CLASSPATH&#125;:$&#123;HBASE_HOME&#125;/lib&#x27;/*&#x27;<br>fi<br></code></pre></td></tr></table></figure><p>保存后重新输入命令，可正常执行。</p><h4id="安装r依赖库recharts的网络问题">3.安装R依赖库recharts的网络问题</h4><p>连接时会显示如下错误：</p><figure><img src="image-20200601115111097.png" alt="image-20200601115111097" /><figcaption aria-hidden="true">image-20200601115111097</figcaption></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">install_github</span><span class="hljs-params">(<span class="hljs-string">&#x27;ramnathv/htmlwidgets&#x27;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">install_github</span><span class="hljs-params">(<span class="hljs-string">&#x27;rstudio/htmltools&#x27;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">install_github</span><span class="hljs-params">(<span class="hljs-string">&#x27;taiyun/recharts@htmlwidgets&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure><blockquote><p>参考https://github.com/cosname/recharts/issues/23或使用代理操作</p></blockquote><h4 id="安装r-studio">4.安装R studio</h4><blockquote><p>参考：https://www.cnblogs.com/taoyuyeit/p/11266409.html</p></blockquote><h4 id="r-studio中进行debug待补充">5.R studio中进行debug（待补充）</h4><p><br></p><blockquote><p>实验指导书参考：</p><p><ahref="http://dblab.xmu.edu.cn/blog/959/">步骤一：本地数据集上传到数据仓库Hive</a></p><p><ahref="http://dblab.xmu.edu.cn/blog/1005/">步骤二：Hive数据分析</a></p><p><ahref="http://dblab.xmu.edu.cn/blog/1059-2/">步骤三：Hive、MySQL、HBase数据互导</a></p><p><ahref="http://dblab.xmu.edu.cn/blog/1130-2/">步骤四:利用R进行数据可视化分析</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文用于记录《大数据科学与应用》这门课程的种种…..&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Nginx安装记录</title>
    <link href="https://chakkk309.github.io/2020/03/28/nginxrecord/"/>
    <id>https://chakkk309.github.io/2020/03/28/nginxrecord/</id>
    <published>2020-03-28T12:57:08.000Z</published>
    <updated>2022-08-27T14:10:43.088Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下Nginx的安装过程和实例练习</p><span id="more"></span><h3 id="编译安装">编译安装</h3><p><strong>下载</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install wget<br>cd /usr/local &amp;&amp; wget http://nginx.org/download/nginx-1.16.1.tar.gz<br></code></pre></td></tr></table></figure><p><strong>环境准备</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y gcc-c++<br>yum install -y pcre pcre-devel<br>yum install -y zlib zlib-devel<br>yum install -y openssl openssl-devel<br></code></pre></td></tr></table></figure><p><strong>解压</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local &amp;&amp; tar -zxvf nginx-1.16.1.tar.gz<br></code></pre></td></tr></table></figure><p><strong>编译安装</strong>：<code>./configure</code>是个shell脚本，用来检测安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC；make从Makefile中读取指令然后编译；makeinstall同样也从Makefile中读取指令，安装到指定位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/nginx-1.16.1 &amp;&amp; ./configure --prefix=/usr/local/nginx<br>make<br>make install<br></code></pre></td></tr></table></figure><p><strong>配置环境变量</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /etc/profile<br><span class="hljs-meta prompt_"># </span><span class="language-bash">最下面新起一行，插入如下</span><br>nginx=/usr/local/nginx/sbin<br>export PATH=$PATH:$nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使配置文件生效</span><br>source /etc/profile<br></code></pre></td></tr></table></figure><p><strong>启动</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx<br></code></pre></td></tr></table></figure><p><strong>访问测试</strong></p><p><strong>关闭</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">快速停止</span><br>nginx -s stop<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">平缓停止</span><br>nginx -s quit<br></code></pre></td></tr></table></figure><p>重启：重新加载配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -s reload<br></code></pre></td></tr></table></figure><p>检测配置文件语法是否正确</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">指定需要检查的配置文件</span><br>nginx -t -c  /usr/local/nginx/conf/nginx.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">不加 -c 参数，默认检测nginx.conf配置文件（常用）</span><br>nginx -t <br></code></pre></td></tr></table></figure><hr /><h3 id="yum安装">yum安装</h3><p>下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install nginx<br></code></pre></td></tr></table></figure><p>常用操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">设置开机启动</span><br>systemctl enable nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动nginx服务</span><br>service nginx start<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止nginx服务</span><br>service nginx stop<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启nginx服务</span><br>service nginx restart<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重新加载配置，一般是在修改过nginx配置文件时使用</span><br>service nginx reload<br></code></pre></td></tr></table></figure><p>常用文件</p><ul><li>配置文件：/etc/nginx/nginx.conf</li><li>自定义的配置文件：/etc/nginx/conf.d</li><li>项目文件：/usr/share/nginx/html/</li><li>日志文件：/var/log/nginx/</li><li>其他安装文件都在/etc/nginx</li><li>使用<code>find  /  -name  nginx*</code>全局查找与nginx相关的文件</li></ul><p>安装网络工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install net-tools<br></code></pre></td></tr></table></figure><p>查看80端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -anpt|grep 80<br></code></pre></td></tr></table></figure><hr /><h3 id="正向代理">正向代理</h3><p>比如科学上网VPN就是一个典型的例子，正向代理服务器位于客户端和服务器之间，为了向服务器获取数据，客户端要向代理服务器发送一个请求，并指定目标服务器，代理服务器将目标服务器返回的数据转交给客户端。</p><p><img src="正向代理.jpg" /></p><hr /><h3 id="反向代理">反向代理</h3><blockquote><p>实例目标：使用 nginx 反向代理 <code>www.123.com</code>直接跳转到<code>192.168.0.103:8080</code></p></blockquote><p>启动tomcat<code>（192.168.0.103:8080）</code></p><p>修改windows本地host文件，添加映射关系。hosts一般在<code>C:\Windows\System32\drivers\etc\hosts</code>目录下，它是一个没有扩展名的系统文件，IP解析优先级比DNS要高。若没有修改权限，可右键-&gt;属性-&gt;安全-&gt;修改权限；或将hosts移动到桌面，修改后复制回原文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">192.168.0.103  www.123.com<br></code></pre></td></tr></table></figure><p>此时，可以通过<code>www.123.com:8080</code>访问tomcat了</p><p>使用Nginx反向代理</p><ul><li>找到nginx.conf，并编辑</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /usr/local/nginx/conf/nginx.conf<br></code></pre></td></tr></table></figure><ul><li>nginx.conf核心配置如下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">server &#123;<br>    listen       80;                           # 监听80端口（默认）<br>    server_name  www.123.com;                  # 虚拟主机名（用来指定IP地址或者域名，多个域名之间用空格分开）<br><br>    location / &#123;                               # 访问根目录（如果有多个location，会从最长前缀开始匹配，此location匹配http://www.123.com/）<br>        proxy_pass http://192.168.0.103:8080;<br>        root   html;                           # 用于指定虚拟主机的网页根目录，这个目录可以是相对路径，也可以是绝对路径<br>        index  index.html index.htm index.jsp; # 用于设置网站的默认首页，后面的文件名称可以有多个，中间用空格隔开，第一个找不到，则找第二个，以此类推<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>重新加载nginx配置文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -s reload<br></code></pre></td></tr></table></figure><p>实例结果：访问<code>www.123.com</code>直接跳转到<code>192.168.0.103:8080</code>也就是tomcat启动页面</p><blockquote><p>Nginx搭建在192.168.0.103这台虚拟机上，在本机也就是客户端，访问<code>www.123.com</code>，会发生什么？</p></blockquote><p>实例分析：</p><p>1.检查本地hosts文件，发现有该域名的解析，拿到解析的ip：192.168.0.103</p><p>2.http请求连接到了192.168.0.103的80端口</p><p>3.Nginx的80端口一直在被监听，服务器发现请求的uri为/，host为<code>www.123.com</code>，进而匹配到server_name·<code>www.123.com</code>，并且转到了location / 也就是代理服务器<code>http://192.168.0.103:8080</code>，至此访问成功。</p><p>在这个反向代理过程中，客户端把请求交给Nginx，由Nginx的配置文件制定一些规则把请求转发给服务器，客户端并不知道谁为自己提供了服务，<strong>反向代理，其实代理的是服务器</strong>。</p><p>抓个包来理一下思路，进行报文过滤，只留下相关的http传输作为重点进行分析。</p><p><img src="overall.png" /></p><p>三次握手建立连接之后，客户端向Nginx服务器发起请求。</p><p><img src="90_get.png" /></p><p>可以看到客户端请求使用HTTP1.1协议Get方法访问根目录内容，请求的域名为<code>www.123.com</code>。</p><p><img src="126_ok.png" /></p><p>服务器响应了请求，状态码200OK，回应的Web服务器为Nginx。</p><p>又相继传输了HTML和CSS样式以及加载页面所需要的图片，可以看到这个过程中，没有出现被代理服务器的任何信息，也与”反向代理，其实代理的是服务器“这句话相呼应。</p><h3 id="负载均衡">负载均衡</h3><p>负载均衡主要通过专门的硬件设备或者软件算法实现。而通过软件实现的负载均衡主要依赖于均衡算法的选择和程序的健壮性。均衡算法又主要分为两大类：</p><ul><li><p>静态负载均衡算法：主要包括轮询算法、基于比率的加权轮询算法或者基于优先级的加权轮询算法。</p></li><li><p>动态负载均衡算法：主要包括基于任务量的最少连接优化算法、基于性能的最快响应优先算法、预测算法及动态性能分配算法等。</p></li></ul><p>前期准备</p><ul><li>复制3个tomcat，分别命名8081、8082、8083作为区分。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp -r /usr/local/apache-tomcat-8.5.53/ /usr/local/tomcat8081<br></code></pre></td></tr></table></figure><ul><li>修改相应<code>conf/server.xml</code>中的端口号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;Server port=&quot;8006&quot; shutdown=&quot;SHUTDOWN&quot;&gt;<br>&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot;<br></code></pre></td></tr></table></figure><ul><li>修改相应的h1标题作为区分</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;h1&gt;$&#123;pageContext.servletContext.serverInfo&#125;-【192.168.0.102:8081】&lt;/h1&gt;<br></code></pre></td></tr></table></figure><ul><li>启动3个tomcat服务</li></ul><h4 id="普通轮询算法">普通轮询算法</h4><p>实现内容：输入<code>www.123.com</code>在3个tomcat服务之间进行切换</p><ul><li><p>编辑配置文件<code>nginx.conf</code></p></li><li><p>核心内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream OrdinaryPolling &#123;                     # 主要用于负载均衡，设置一系列的后端服务器<br>       server 192.168.0.102:8081;<br>       server 192.168.0.102:8082;<br>       server 192.168.0.102:8083;<br>   &#125;<br>  <br>   server &#123;<br>       listen       80;                           # 监听80端口（默认）<br>       server_name  www.123.com;                  # 虚拟主机名（用来指定IP地址或者域名，多个域名之间用空格分开）<br>  <br>       location / &#123;                               # 访问根目录（如果有多个location，会从最长前缀开始匹配，此location匹配http://www.123.com/）<br>           proxy_pass http://OrdinaryPolling;<br>           root   html;                           # 用于指定虚拟主机的网页根目录，这个目录可以是相对路径，也可以是绝对路径<br>           index  index.html index.htm index.jsp; # 用于设置网站的默认首页，后面的文件名称可以有多个，中间用空格隔开，第一个找不到，则找第二个，以此类推<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li><li><p>重新加载配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -s reload<br></code></pre></td></tr></table></figure></li></ul><p>实例访问成功</p><h4 id="基于比例加权轮询">基于比例加权轮询</h4><p>某台服务器性能更高，根据他的自身能力可以处理更多的请求</p><ul><li><p>编辑nginx.conf文件，在负载均衡设置中添加weight选项。该指令用于配置前面请求处理的权重，默认值为1。也就是说，上文不加权的普通轮询，其实其加权值 weight 都为 1。</p></li><li><pre class="shell"><code>  server 192.168.0.102:8081 weight=6;  server 192.168.0.102:8082 weight=2  server 192.168.0.102:8083 weight=2;</code></pre></li><li><p>重新加载配置文件</p></li><li><p>实例结果：访问 <code>www.123.com</code>跳转到<code>192.168.0.102:8081</code>次数增多。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下Nginx的安装过程和实例练习&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis安装记录</title>
    <link href="https://chakkk309.github.io/2020/03/24/redisrecord/"/>
    <id>https://chakkk309.github.io/2020/03/24/redisrecord/</id>
    <published>2020-03-24T08:27:17.000Z</published>
    <updated>2022-08-27T14:18:50.973Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下Redis安装过程：</p><blockquote><p>选择一个<a href="https://redis.io/documentation">Redis</a>稳定版本下载</p><p><a href="https://redisdesktop.com/">Redis Desktop Manager</a>作为管理工具</p></blockquote><h3 id="虚拟机centos-7.7设置静态ip">虚拟机CentOS 7.7设置静态ip</h3><p>1.使用ipconfig查看并记录本机的<strong>ip</strong>、<strong>子网掩码</strong>和<strong>网关</strong>。</p><p><img src="ipconfig.png" /></p><p>2.进入虚拟机网卡目录</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /etc/sysconfig/network-scripts/&amp;&amp;ls<br></code></pre></td></tr></table></figure></p><p><img src="ens33.png" /></p><p>3.编辑网卡的配置文件 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi ifcfg-ens33<br></code></pre></td></tr></table></figure> <img src="content.png" /></p><p>4.具体增添的配置内容如下，BOOTPROTO修改为静态ip，并添加ip，子网掩码和网关。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">BOOTPROTO=&quot;static&quot;<br>IPADDR=192.168.0.105<br>NETMASK=255.255.255.0<br>GATEWAY=192.168.0.1<br></code></pre></td></tr></table></figure></p><p>5.保存修改并使重启网络服务 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart network.service<br></code></pre></td></tr></table></figure></p><p>验证接口是否配置正确： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip add<br></code></pre></td></tr></table></figure> <img src="ok.png" /></p><p>也可以ping一下本机或者任意网站进行测试</p><h3 id="编译安装redis2.8.17">编译安装Redis2.8.17</h3><p>1.安装<code>wget</code> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install wget<br></code></pre></td></tr></table></figure></p><p>使用wget下载，并在<code>\usr\local</code> 目录下载redis并解压<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local<br>wget http://download.redis.io/releases/redis-2.8.17.tar.gz<br>tar xzf redis-2.8.17.tar.gz<br></code></pre></td></tr></table></figure></p><p>2.安装gcc <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install gcc-c++<br></code></pre></td></tr></table></figure></p><p>3.在redis目录下进行make操作</p><p>src目录下，会生成编译后的redis服务程序<strong>redis-server</strong>和用于测试的客户端程序<strong>redis-cli</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sell">cd redis-2.8.17<br>make<br></code></pre></td></tr></table></figure> 也可以使用make test，是为了验证make是否成功，是否完整。</p><p>4.启动redis服务 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd src<br>./redis-server<br></code></pre></td></tr></table></figure></p><p>5.使用测试客户端程序redis-cli和redis服务交互</p><p>启动客户端之后可以执行<code>PING</code>命令来检测服务是否启动。</p><p>在redis-cli 后面加上--raw即<code>redis-cli --raw</code>可以有效避免中文乱码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/redis-2.8.17/src &amp;&amp; ./redis-server<br>./redis-cli<br>set foo bar<br>get foo<br></code></pre></td></tr></table></figure><p>6.查看运行状态并关闭进程 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef|grep redis<br>kill 9 pid<br></code></pre></td></tr></table></figure></p><p>7.开启守护进程（Daemon Process），是 Linux中的后台服务进程。它脱离终端，为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/redis-2.8.17<br>vi redis.conf<br>修改daemonize no为daemonize yes<br>ps -ef|grep redis<br>kill 9 (pid)<br>cd src<br>./redis-server ../redis.conf<br></code></pre></td></tr></table></figure><h3 id="编译安装redis主从配置">编译安装Redis主从配置</h3><p>例：现在有两个虚拟机：ip分别为192.168.0.105（主机）和192.168.0.103（从机）</p><p><strong>从节点配置</strong> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/redis-2.8.17<br>vi redis.conf<br></code></pre></td></tr></table></figure></p><p>修改daemonize no为<strong>daemonize yes</strong>修改bind127.0.0.1为<strong>192.168.0.105</strong></p><p><strong>主节点配置</strong> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/redis-2.8.17<br>vi redis.conf<br></code></pre></td></tr></table></figure></p><p>修改daemonize no 为 <strong>daemonize yes</strong> ，即开启守护进程。修改# slaveof <masterip> <masterport> 取消注释，设置为 <strong>slaveof192.168.0.105 6379</strong> ，当设置当本机为 slav 服务时，设置 master服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master进行数据同步。</p><p>修改# repl-ping-slave-period 10，取消注释，设置为<strong>repl-ping-slave-period 10</strong></p><p><strong>两台机器全部启动redis服务</strong><br /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/redis-2.8.17/src<br>./redis-server ../redis.conf<br>ps -ef|grep redis  # 查看进程<br></code></pre></td></tr></table></figure></p><p><strong>启动redis客户端</strong></p><p>主机启动，因为已经绑定了ip，所以要指定主机使用参数h<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./redis-cli -h 192.168.0.105<br></code></pre></td></tr></table></figure></p><p>从机启动 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./redis-cli<br></code></pre></td></tr></table></figure></p><p>确认连接情况，观察是否role已经正确设置为master/slave</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">INFO replication<br></code></pre></td></tr></table></figure><p><strong>设置成功后进行存储测试</strong></p><p>主机：存入数据1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set test 1<br></code></pre></td></tr></table></figure><p>从机：取出成功，得到1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">get test<br></code></pre></td></tr></table></figure><h3 id="yum安装redis并设置主从同步">yum安装Redis并设置主从同步</h3><p>1.安装并自动下载3.2.12-2版本</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install epel-release<br>yum install redis<br></code></pre></td></tr></table></figure></p><p>2.修改配置文件</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /etc/redis.conf<br>修改内容同上tar<br></code></pre></td></tr></table></figure></p><p>3.启动redis服务</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-server /etc/redis.conf<br></code></pre></td></tr></table></figure></p><p>4.启动客户端</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">主：redis-cli -h 192.168.0.105<br>从：redis-cli <br></code></pre></td></tr></table></figure></p><p>5.确认情况</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">INFO replication<br></code></pre></td></tr></table></figure></p><p>6.同步测试</p><h3 id="一些问题">一些问题</h3><h4 id="产生swap文件">产生swap文件</h4><p>vi命令操作配置文件的时候：中途意外退出，会产生临时文件【.配置文件名.swp】</p><p>再次使用，可以直接【rm -f .配置文件名.swp】，然后正常编辑。</p><p>例：<code>rm -f /etc/.redis.conf.swp</code> ，直接删除或者进行覆盖。<img src="swp.png" /></p><h4 id="版本不一致">版本不一致</h4><p>不同版本的Redis不要搭建主从，以免发生问题。比如通过yum安装的版本和编译下载的版本就不一致，配置主从同步需要版本一致！最好不要同时使用两种方法安装，以免混淆！</p><h4 id="卸载文件不彻底">卸载文件不彻底</h4><p>问题：执行了<code>yum remove redis</code>命令。此时，redis.conf被vi等打开，删除的时候会出现警告： 警告：/etc/redis.conf 已另存为/etc/redis.conf.rpmsave 。此时，保留了/etc/redis.conf.rpmsave文件，再次yum installredis的时候，/etc/redis.conf会被创建为一个新的空文件，导致问题出现。</p><p>解决方法： 删除/etc/redis.conf.rpmsave等文件</p><h4id="配置静态ip后无法ping通外部网络">配置静态ip后无法ping通外部网络</h4><p>1.未知的名称或服务 <img src="DNS_error.png" />一般是域名解析没有成功，在配置文件中设置DNS服务器，默认与网关ip相同。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">DNS1 = XXX;<br></code></pre></td></tr></table></figure><p>重新加载配置文件并启动网络即可。</p><p>2.启动网卡报错 Failed to start LSB: Bring up/down networking禁用NetworkManager <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop NetworkManager<br>systemctl disable NetworkManager<br></code></pre></td></tr></table></figure> 重新启动网络即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下Redis安装过程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;选择一个&lt;a href=&quot;https://redis.io/documentation&quot;&gt;Redis&lt;/a&gt;
稳定版本下载&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://redisdesktop.com</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hexo Installation</title>
    <link href="https://chakkk309.github.io/2020/03/22/retrivehexo/"/>
    <id>https://chakkk309.github.io/2020/03/22/retrivehexo/</id>
    <published>2020-03-22T13:34:01.000Z</published>
    <updated>2022-08-25T18:11:25.814Z</updated>
    
    <content type="html"><![CDATA[<p>最新重装了一下系统，一夜回到解放前。还好存了hexo备份，配置文件还在。但是以防万一再遇到类似窘境，还是记录一下找回过程吧~</p><span id="more"></span><h4 id="安装node.js">安装node.js</h4><h4 id="安装git">安装git</h4><h4 id="安装hexo">安装hexo</h4><ul><li>使用npm安装hexo</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-cli -g<br></code></pre></td></tr></table></figure><ul><li>选好一个blog文件夹，进行初始化</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init blog<br></code></pre></td></tr></table></figure><ul><li><p>使用备份好的文件进行覆盖/替换</p></li><li><p>安装部署插件</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-deployer-git –save<br></code></pre></td></tr></table></figure><h4 id="配置git信息">配置git信息</h4><ul><li><p>blog文件夹中右键 -&gt;Git Bash Here，设置信息（用户名和密码）</p><p>这里也可以将其参数设置为global，表示这台电脑上所有的Git仓库都会使用这个配置，也可以对某个仓库指定不同的用户名和Email地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git config  (--global) user.name &quot;你的GitHub用户名&quot;<br>git config  (--global) user.email &quot;你的GitHub注册邮箱&quot;<br></code></pre></td></tr></table></figure></li></ul><h4 id="配置ssh">配置SSH</h4><ul><li><p>生成ssh秘钥，直接Enter*3默认不需要密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;<br></code></pre></td></tr></table></figure></li><li><p>找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容复制，进入<ahref="https://link.zhihu.com/?target=https%3A//github.com/settings/ssh">https://github.com/settings/ssh</a>中</p></li><li><p>点击New SSH key，title随意，key填入刚才复制的公钥，Add SSHkey即可。</p></li><li><p>回到Git Bash中检测GitHub公钥设置是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">ssh git@github.com<br></code></pre></td></tr></table></figure><p>可能会出现以下错误：</p><figure><img src="error.png" alt="error.png" /><figcaption aria-hidden="true">error.png</figcaption></figure><p>因为.ssh文件夹中缺少一个<code>known_hosts</code>文件，选择yes继续连接就会自动生成该文件。</p><figure><img src="host.png" alt="host.png" /><figcaption aria-hidden="true">host.png</figcaption></figure><p>ssh会把每个访问过计算机的公钥(publickey)都记录在known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告，避免受到DNS Hijack之类的攻击。</p><p>文件补齐后，下次再登录时就可以进行正常操作啦~</p><figure><img src="normal.png" alt="normal.png" /><figcaption aria-hidden="true">normal.png</figcaption></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最新重装了一下系统，一夜回到解放前。还好存了hexo备份，配置文件还在。但是以防万一再遇到类似窘境，还是记录一下找回过程吧~&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hi! 2020</title>
    <link href="https://chakkk309.github.io/2020/02/01/hi2020/"/>
    <id>https://chakkk309.github.io/2020/02/01/hi2020/</id>
    <published>2020-01-31T16:40:49.000Z</published>
    <updated>2022-08-28T05:15:26.343Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自说自话王国-欢迎光临">自说自话王国 欢迎光临 :)<br></h3><blockquote><p>拍电影的时候要把摄影机和收音器材同时调到24格，声音和画面才会同步，差一格都不行。其实拍电影和做人一样，每个镜头都是在不断的错过。——小樱/陪安东尼度过漫长岁月</p></blockquote><span id="more"></span><p>苏打绿史俊威写过一首歌叫做《频率》，他说写歌缘由是人不断地揣测上帝在我们身上的计划与安排，却找不到正确的频率导致常常收不到上帝的回应（就和我时常担心带着Hogwarts录取通知书的猫头鹰找不到来我家的路一样）。</p><p>歌中从与上帝的对话写到人与人互动相处的感觉以及和周围事物的关系，如同窦文涛在一次访谈中问的一样，”人与人之间的默认值已经大为改变，这个怎么解？“。要怎么办，才能在跳动的时间里找到你的频率，又或是在流动的时间里找你的旋律呢？是不是真的只有透过双手，爱才会有交直流呢？</p><p>现在大众越来越拿超社会的生物关系和理性计算来作为一个意义的基础，使用大数据信息对比来找出相匹配的人。一方面可能是经济理性的极度扩张，把原来那种爱的感觉消灭掉了；另一个更却近的解释就是：我们好像丧失了在附近构造出一种爱的关系的自信，丧失了寻找同一频率的能力。</p><p>微软有一个研究说2000年人维持高度关注的持续时间是十五秒，到2013年，十三年过去，也正是电子产品开始普及的时间，人的专注力迅速缩减到8秒钟以内，就是说，对一件事情的专注只有八秒钟，堪比一条鱼的记忆。互联网思维驱动下，我们以为看到了更大的世界，却不知留给自己的空间越来越小。罗大佑说，现在这个时代找东西太容易了，所以你只会看你想看的，长此以往就越来越成为你自己。信息过载，碎片认知，是无法保持专注的孪生兄弟。在大环境下，如何自洽，如何不被精神殖民，是一个值得思考的问题。听多了谎言，如何才能分辨出真相？我们真的知道自己为什么哭和笑吗？有些“故步自封”的能力也不见得是坏事，人总要有一个框，诱惑是没有边的，新的转机和闪闪星斗是没有边的，因为现在得到太容易了。<br></p><hr><h3 id="关于这个博客"><strong>关于这个博客</strong></h3><p>用于记录生活学习中的点滴以及无数个被卡住的瞬间，可能99%的内容都是废话，但毕竟存在即合理，我思故我在嘛。「一方面你知道宇宙有多大，另一方面你知道每个个体都应该有自己的声音，哪怕再渺小」<br></p><h3 id="关于chakkk"><strong>关于Chakkk</strong></h3><p>有点像生活在仓鼠球中的人类，有自己的小小世界。</p><ul><li><p><strong>Chakkk的问号</strong></p><p><del>等到我学会开车时，全世界的石油都用完了，那该怎么办？</del><strong>Get :)</strong></p><p><del>如果我是某个对象的唯一引用却又被设定成null，为什么让我吃到这么好吃的叉烧饭，万一以后吃不到怎么办？</del>停下来想想，自己是真的喜欢吃叉烧饭吗？</p></li><li><p><strong>Chakkk对于这个世界的理解</strong>：星星偏离了臆想中的预设就伤心不已觉得天崩地裂，梦醒了拍拍屁股走人也没有什么损失；庙上不见顶上见</p></li><li><p><strong>Chakkk2020的关键字</strong>：「carpe diem」, We‘re gonnadie soon and there's no sequel.周边的事物总会逝去，珍惜在家陪伴亲人的日子以及还能在学校和朋友们相处的时间，把握当下。</p></li><li><p><strong>Chakkk2020的一个小目标</strong>：学会发上旋球！</p></li></ul><p><br></p><p>虽然找到频率相同的人很难，可是现在，我们共同拥有这一分钟，不是吗？<br>欢迎光临，谢谢惠顾，赠送一篇猹言猹语。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;自说自话王国-欢迎光临&quot;&gt;自说自话王国 欢迎光临 :)&lt;br&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;拍电影的时候要把摄影机和收音器材同时调到24格，声音和画面才会同步，差一格都不行。其实拍电影和做人一样，每个镜头都是在不断的错过。——小樱/陪安东尼度过漫长岁月&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
